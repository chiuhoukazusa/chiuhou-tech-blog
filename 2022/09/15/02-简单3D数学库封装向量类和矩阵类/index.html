<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>02.简单3D数学库|封装向量类和矩阵类 | Chiuhou 技术博客</title><meta name="author" content="Chiuhou"><meta name="copyright" content="Chiuhou"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="02.简单3D数学库|封装向量类和矩阵类本项目代码已托管至github，将会随着博客实时更新进度每一节的工程我都会创建一个新的分支，分支名由这一节的数字决定。 https:&#x2F;&#x2F;github.com&#x2F;chiuhoukazusa&#x2F;LearningTinyrenderer&#x2F;tree&#x2F;02 前言在上一节的工程中，给定两个点，我们已经做到成功画出一条唯一确定的线段了。但是为了我们以后方便，我们显然需要封装向">
<meta property="og:type" content="article">
<meta property="og:title" content="02.简单3D数学库|封装向量类和矩阵类">
<meta property="og:url" content="https://chiuhoukazusa.github.io/2022/09/15/02-%E7%AE%80%E5%8D%953D%E6%95%B0%E5%AD%A6%E5%BA%93%E5%B0%81%E8%A3%85%E5%90%91%E9%87%8F%E7%B1%BB%E5%92%8C%E7%9F%A9%E9%98%B5%E7%B1%BB/index.html">
<meta property="og:site_name" content="Chiuhou 技术博客">
<meta property="og:description" content="02.简单3D数学库|封装向量类和矩阵类本项目代码已托管至github，将会随着博客实时更新进度每一节的工程我都会创建一个新的分支，分支名由这一节的数字决定。 https:&#x2F;&#x2F;github.com&#x2F;chiuhoukazusa&#x2F;LearningTinyrenderer&#x2F;tree&#x2F;02 前言在上一节的工程中，给定两个点，我们已经做到成功画出一条唯一确定的线段了。但是为了我们以后方便，我们显然需要封装向">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://chiuhoukazusa.github.io/images/lianlian.jpg">
<meta property="article:published_time" content="2022-09-15T04:09:00.000Z">
<meta property="article:modified_time" content="2026-02-10T08:51:00.732Z">
<meta property="article:author" content="Chiuhou">
<meta property="article:tag" content="C++">
<meta property="article:tag" content="图形学">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://chiuhoukazusa.github.io/images/lianlian.jpg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "02.简单3D数学库|封装向量类和矩阵类",
  "url": "https://chiuhoukazusa.github.io/2022/09/15/02-%E7%AE%80%E5%8D%953D%E6%95%B0%E5%AD%A6%E5%BA%93%E5%B0%81%E8%A3%85%E5%90%91%E9%87%8F%E7%B1%BB%E5%92%8C%E7%9F%A9%E9%98%B5%E7%B1%BB/",
  "image": "https://chiuhoukazusa.github.io/images/lianlian.jpg",
  "datePublished": "2022-09-15T04:09:00.000Z",
  "dateModified": "2026-02-10T08:51:00.732Z",
  "author": [
    {
      "@type": "Person",
      "name": "Chiuhou",
      "url": "https://chiuhoukazusa.github.io"
    }
  ]
}</script><link rel="shortcut icon" href="/chiuhou-tech-blog/images/favicon.png"><link rel="canonical" href="https://chiuhoukazusa.github.io/2022/09/15/02-%E7%AE%80%E5%8D%953D%E6%95%B0%E5%AD%A6%E5%BA%93%E5%B0%81%E8%A3%85%E5%90%91%E9%87%8F%E7%B1%BB%E5%92%8C%E7%9F%A9%E9%98%B5%E7%B1%BB/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/chiuhou-tech-blog/css/index.css?v=5.5.4"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@7.1.0/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/chiuhou-tech-blog/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.13.0/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '02.简单3D数学库|封装向量类和矩阵类',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 8.1.1"></head><body><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(/chiuhou-tech-blog/images/lianlian.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/chiuhou-tech-blog/"><span class="site-name">Chiuhou 技术博客</span></a><a class="nav-page-title" href="/chiuhou-tech-blog/"><span class="site-name">02.简单3D数学库|封装向量类和矩阵类</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"></div></nav><div id="post-info"><h1 class="post-title">02.简单3D数学库|封装向量类和矩阵类</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-09-15T04:09:00.000Z" title="发表于 2022-09-15 12:09:00">2022-09-15</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2026-02-10T08:51:00.732Z" title="更新于 2026-02-10 16:51:00">2026-02-10</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/chiuhou-tech-blog/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">学习笔记</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h1 id="02-简单3D数学库-封装向量类和矩阵类"><a href="#02-简单3D数学库-封装向量类和矩阵类" class="headerlink" title="02.简单3D数学库|封装向量类和矩阵类"></a>02.简单3D数学库|封装向量类和矩阵类</h1><h2 id="本项目代码已托管至github，将会随着博客实时更新进度"><a href="#本项目代码已托管至github，将会随着博客实时更新进度" class="headerlink" title="本项目代码已托管至github，将会随着博客实时更新进度"></a>本项目代码已托管至github，将会随着博客实时更新进度</h2><p>每一节的工程我都会创建一个新的分支，分支名由这一节的数字决定。</p>
<p><a target="_blank" rel="noopener" href="https://github.com/chiuhoukazusa/LearningTinyrenderer/tree/02">https://github.com/chiuhoukazusa/LearningTinyrenderer/tree/02</a></p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在上一节的工程中，给定两个点，我们已经做到成功画出一条唯一确定的线段了。但是为了我们以后方便，我们显然需要封装向量类和矩阵类。当然我们可以直接使用Eigen库来完成这个问题，Eigen库非常的好用，但是我更想自己写一个试试。我们要做的其实完全不复杂，仅仅是封装几个类，并且没有什么性能要求，不会涉及到使用一些指令集来进行加速。所有的一切都将只用一些比较简单的c++代码进行实现。</p>
<p>本节代码参考了一部分pbrt-v3的配套代码中的geometry.h文件中的实现方式和DirectXMath库的设计方式，来封装一些简单的涉及3d数学的类。以下是pbrt-v3的源码：</p>
<p><a target="_blank" rel="noopener" href="https://github.com/mmp/pbrt-v3">https://github.com/mmp/pbrt-v3</a></p>
<h2 id="我们需要做的"><a href="#我们需要做的" class="headerlink" title="我们需要做的"></a>我们需要做的</h2><p>pbrt-v3中的数学库实现相当细致，不仅仅只是封装了向量和矩阵，而是将点、法线等等也跟向量区分了开来。</p>
<p>这也算是必要的工作，因为这样就从根源上排除了一些非法操作，例如将点与点相乘等。同时pbrt-v3还封装了Transform类，里面会大量使用到点、向量等数学运算，因此pbrt-v3这样做是非常合适的。</p>
<p>而我们暂时只封装向量和矩阵类，为了简单而言。因为我们正式的一些渲染流程都还没写，在这种情况下死磕数学库我认为不是一个理智的决定，而且我们也没有使用到SIMD指令集来加速。因此我的构思是先用着，等后续有机会了会再来一节3d数学库的完善和重构，届时我会尽量细致地学习并编写一个好用的高性能的3d数学库，当前的目标则是“能用就行”。</p>
<h2 id="向量（以Vector3为例）"><a href="#向量（以Vector3为例）" class="headerlink" title="向量（以Vector3为例）"></a>向量（以Vector3为例）</h2><p>相比起矩阵来说，向量无疑算是比较简单的。以三维向量为例，我们先定义一个模板，顺带写几个构造函数：</p>
<pre><code>1  
2  
3  
4  
5  
6  
7  
8  
9  
10  
</code></pre>
<p>| </p>
<pre><code>namespace myEigen {  
	template&lt;typename T&gt;  
	class Vector3 {  
	public:  
		T x, y, z;  
		Vector3():x(0), y(0), z(0){}  
		Vector3(T x):x(x), y(x), z(x){}  
		Vector3(T x, T y, T z) :x(x), y(y), z(z) {}  
	};  
}  
  
</code></pre>
<p>—|—  </p>
<h3 id="向量的运算符重载与函数"><a href="#向量的运算符重载与函数" class="headerlink" title="向量的运算符重载与函数"></a>向量的运算符重载与函数</h3><p>我们的下一步就是重载运算符，将原本用于标量的加减乘除重载为适用于向量的形式。</p>
<p>同样也很简单，就不用复习一遍公式了，直接写，先从加减开始：</p>
<pre><code>1  
2  
3  
4  
5  
6  
7  
8  
9  
10  
11  
12  
13  
14  
15  
16  
17  
18  
19  
20  
21  
</code></pre>
<p>| </p>
<pre><code>Vector3&lt;T&gt;&amp; operator=(const Vector3&lt;T&gt;&amp; v) {  
	x = v.x, y = v.y, z = v.z;  
	return *this;  
}  
Vector3&lt;T&gt; operator+(const Vector3&lt;T&gt;&amp; v) const {  
	return Vector3(x + v.x, y + v.y, z + v.z);  
}  
Vector3&lt;T&gt;&amp; operator+=(const Vector3&lt;T&gt;&amp; v) {  
	x += v.x, y += v.y, z += v.z;  
	return *this;  
}  
Vector3&lt;T&gt; operator-(const Vector3&lt;T&gt;&amp; v) const {  
	return Vector3(x - v.x, y - v.y, z - v.z);  
}  
Vector3&lt;T&gt;&amp; operator-=(const Vector3&lt;T&gt;&amp; v) {  
	x -= v.x, y -= v.y, z -= v.z;  
	return *this;  
}  
Vector3&lt;T&gt; operator-() const {  
	return Vector3&lt;T&gt;(-x, -y, -z);  
}  
  
</code></pre>
<p>—|—  </p>
<p>也比较简单，不过从乘除开始情况就稍微有点不一样了。</p>
<p>向量乘法有点积和叉积，那么我们要重载的是哪一种乘法？</p>
<p>哪种都不是，我们将直接把两个向量的各个分量一一对应分别相乘为一个新的向量的分量。这听起来很奇怪，但是这样的运算在后续中将会用到很多次，最常见的就是我们将颜色进行混合时，两个颜色以这种方式相乘的结果就是ps里的正片叠底。</p>
<p>而且不仅仅只有这一种情况，向量不一定会跟向量相乘，如果向量跟一个标量相乘，那么结果也不一样。记住这几点就可以写出代码了，顺便为了方便再把平方、取长度和归一化也一起写了：</p>
<pre><code>1  
2  
3  
4  
5  
6  
7  
8  
9  
10  
11  
12  
13  
14  
15  
16  
17  
18  
19  
20  
21  
22  
23  
24  
25  
26  
27  
28  
29  
30  
31  
32  
33  
34  
35  
36  
</code></pre>
<p>| </p>
<pre><code>template&lt;typename U&gt;  
Vector3&lt;T&gt; operator*(U s) const {  
	return Vector3&lt;T&gt;(x * s, y * s, z * s);  
}  
template&lt;&gt;  
Vector3&lt;T&gt; operator*(const Vector3&lt;T&gt;&amp; v) const {  
	return Vector3&lt;T&gt;(x * v.x, y * v.y, z * v.z);  
}  
template&lt;typename U&gt;  
Vector3&lt;T&gt;&amp; operator*=(U s) {  
	x *= s, y *= s, z *= s;  
	return *this;  
}  
template&lt;typename U&gt;  
Vector3&lt;T&gt; operator/(U s) const {  
	return Vector3&lt;T&gt;(x / s, y / s, z / s);  
}  
template&lt;&gt;  
Vector3&lt;T&gt; operator/(Vector3&lt;T&gt; v) const {  
	return Vector3&lt;T&gt;(x / v.x, y / v.y, z / v.z);  
}  
template&lt;typename U&gt;  
Vector3&lt;T&gt;&amp; operator/=(U s) {  
	x /= s, y /= s, z /= s;  
	return *this;  
}  
float Norm() const {  
	return x * x + y * y + z * z;  
}  
float Length() const {  
	return std::sqrt(Norm());  
}  
Vector3&lt;T&gt;&amp; Normalize() {  
	operator/=(Length());  
	return *this;  
}  
  
</code></pre>
<p>—|—  </p>
<p>但是这还没有完成，仔细思考一下会发现我们重载的乘法运算符只能用于向量乘以标量的情况。但如果只是将二者调换一下，让标量乘以向量，这在数学上完全说得通，但是在我们的代码里就不行，所以我们需要定义一个友元。以及&lt;&lt;运算符的重载也需要在友元中进行，所以我们一起写了：</p>
<pre><code>1  
2  
3  
4  
5  
6  
</code></pre>
<p>| </p>
<pre><code>friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const Vector3&lt;T&gt;&amp; v) {  
	return os &lt;&lt; v.x &lt;&lt; &quot;,&quot; &lt;&lt; v.y &lt;&lt; &quot;,&quot; &lt;&lt; v.z;  
}  
friend Vector3&lt;T&gt; operator*(const T&amp; r, const Vector3&lt;T&gt;&amp; v) {  
	return Vector3&lt;T&gt; * r;  
}  
  
</code></pre>
<p>—|—  </p>
<p>我们依旧还没有写点积和叉积，这些我们将在类的外部定义，同时我们还需要定义一下插值算法，这个我们后期也会用到很多次，简单写一下这三个函数：</p>
<pre><code>1  
2  
3  
4  
5  
6  
7  
8  
9  
10  
11  
12  
13  
14  
</code></pre>
<p>| </p>
<pre><code>template&lt;typename T&gt;  
inline T dotProduct(const Vector2&lt;T&gt;&amp; a, const Vector2&lt;T&gt;&amp; b) {  
	return (a.x * b.x + a.y * b.y);  
}  
  
template&lt;typename T&gt;  
inline Vector3&lt;T&gt; crossProduct(const Vector3&lt;T&gt;&amp; a, const Vector3&lt;T&gt;&amp; b) {  
	return Vector3(a.y * b.z - a.z * b.y, a.z * b.x - a.x * b.z, a.x * b.y - a.y * b.x);  
}  
  
template&lt;typename T&gt;  
inline Vector3&lt;T&gt; lerp(const Vector3&lt;T&gt;&amp; a, const Vector3&lt;T&gt;&amp; b, const float&amp; t) {  
	return a * (1 - t) + b * t;  
}  
  
</code></pre>
<p>—|—  </p>
<h3 id="收尾工作"><a href="#收尾工作" class="headerlink" title="收尾工作"></a>收尾工作</h3><p>最后为了方便我们日后使用，我们使用typedef定义两种不同的向量形式：</p>
<pre><code>1  
2  
</code></pre>
<p>| </p>
<pre><code>typedef Vector3&lt;float&gt; Vector3f;  
typedef Vector3&lt;int&gt; Vector3i;  
  
</code></pre>
<p>—|—  </p>
<p>至此，我们已经写了一个比较完整的三维向量类。我们完全可以将同样的思路放在二维向量和四维向量的封装之中，在此由于篇幅原因不表，记得写一个toVector4(Vector3 v)的函数，给三维到四维函数一个转换。</p>
<p>写完后可以直接修改上一节的drawline()方法，然后进行测试，看看结果是否和预期一致。</p>
<h2 id="矩阵"><a href="#矩阵" class="headerlink" title="矩阵"></a>矩阵</h2><p>矩阵其实非常复杂，我翻了翻PBRTv3中的transform.h，发现他好像只实现了4x4的矩阵。</p>
<p>如果把什么二阶方阵和三阶方阵全都实现一遍的话可能有点多余，我暂时想到会用到矩阵的地方就是仿射变换的时候，所以我们暂时先只实现Martrix4x4就够了。而且也用不上模板，我们只使用martrixf4x4就够了（事实证明打脸了，继续往下看下去就知道了）。</p>
<p>还是跟之前向量一样的思路：</p>
<pre><code>1  
2  
3  
4  
5  
6  
7  
8  
9  
10  
11  
12  
13  
14  
15  
16  
17  
18  
19  
20  
21  
22  
23  
24  
25  
26  
27  
28  
29  
</code></pre>
<p>| </p>
<pre><code>class Matrixf4x4 {  
public:  
	float m[4][4];  
			Matrixf4x4(){  
		m[0][0] = m[1][1] = m[2][2] = m[3][3] = 1.f;  
		m[0][1] = m[0][2] = m[0][3] =   
		m[1][0] = m[1][2] = m[1][3] =   
		m[2][0] = m[2][1] = m[2][3] =  
		m[3][0] = m[3][1] = m[3][2] = 0.f;  
	}  
	Matrixf4x4(float mat[4][4]) { memcpy(m, mat, 16 * sizeof(float)); }  
	Matrixf4x4(float t00, float t01, float t02, float t03,  
		float t10, float t11, float t12, float t13,  
		float t20, float t21, float t22, float t23,  
		float t30, float t31, float t32, float t33)  
	{  
		m[0][0] = t00, m[0][1] = t01, m[0][2] = t02, m[0][3] = t03;  
		m[1][0] = t10, m[1][1] = t11, m[1][2] = t12, m[1][3] = t13;  
		m[2][0] = t20, m[2][1] = t21, m[2][2] = t22, m[2][3] = t23;  
		m[3][0] = t30, m[3][1] = t31, m[3][2] = t32, m[3][3] = t33;  
	}  
	template&lt;typename T&gt;  
	Matrixf4x4(Vector4&lt;T&gt; v0, Vector4&lt;T&gt; v1, Vector4&lt;T&gt; v2, Vector4&lt;T&gt; v3) {  
		m[0][0] = v0.x, m[0][1] = v1.x, m[0][2] = v2.x, m[0][3] = v3.x;  
		m[1][0] = v0.y, m[1][1] = v1.y, m[1][2] = v2.y, m[1][3] = v3.y;  
		m[2][0] = v0.z, m[2][1] = v1.z, m[2][2] = v2.z, m[2][3] = v3.z;  
		m[3][0] = v0.w, m[3][1] = v1.w, m[3][2] = v2.w, m[3][3] = v3.w;  
	}  
};  
  
</code></pre>
<p>—|—  </p>
<p>值得注意的是用四个四维向量构造矩阵的思路，这里我们默认我们的向量是列向量。以后的文章里，如无特殊说明，我们说的向量也都是列向量。</p>
<h3 id="矩阵的运算符重载"><a href="#矩阵的运算符重载" class="headerlink" title="矩阵的运算符重载"></a>矩阵的运算符重载</h3><p>矩阵的运算比较复杂，大部分需要写成函数形式，需要重载的运算符只有+、*和&lt;&lt;。</p>
<p>我们先回顾一下矩阵与向量，矩阵与矩阵的乘法公式：</p>
<p>假设现在有两个4阶方阵A和B，假设结果为T，则</p>
<p>Tnm&#x3D;an1∗b1m+an2∗b2m+an3∗b3m+an4∗b4mT_{nm}&#x3D;a_{n1}*b_{1m}+a_{n2}*b_{2m}+a_{n3}*b_{3m}+a_{n4}*b_{4m} Tnm​&#x3D;an1​∗b1m​+an2​∗b2m​+an3​∗b3m​+an4​∗b4m​</p>
<p>对于4阶方阵A左乘4维列向量B，有</p>
<p>AB&#x3D;[A11A12A13A14A21A22A23A24A31A32A33A34A41A42A43A44][xyzw]&#x3D;[A11x+A12y+A13z+A14wA21x+A22y+A23z+A24wA31x+A32y+A33z+A34wA41x+A42y+A43z+A44w]AB &#x3D;\begin{bmatrix}A_{11}\quad A_{12}\quad A_{13}\quad A_{14}\\ A_{21\quad }A_{22}\quad A_{23}\quad A_{24}\\ A_{31\quad }A_{32}\quad A_{33}\quad A_{34}\\ A_{41\quad }A_{42}\quad A_{43}\quad A_{44} \end{bmatrix}\begin{bmatrix}x\\ y\\ z\\ w \end{bmatrix} &#x3D; \begin{bmatrix}A_{11}x+A_{12}y+A_{13}z+A_{14}w\\ A_{21}x+A_{22}y+A_{23}z+A_{24}w\\ A_{31}x+A_{32}y+A_{33}z+A_{34}w\\ A_{41}x+A_{42}y+A_{43}z+A_{44}w\end{bmatrix} AB&#x3D;​A11​A12​A13​A14​A21​A22​A23​A24​A31​A32​A33​A34​A41​A42​A43​A44​​​​xyzw​​&#x3D;​A11​x+A12​y+A13​z+A14​wA21​x+A22​y+A23​z+A24​wA31​x+A32​y+A33​z+A34​wA41​x+A42​y+A43​z+A44​w​​</p>
<p>那么我们可以写出重载：</p>
<pre><code>1  
2  
3  
4  
5  
6  
7  
8  
9  
10  
11  
12  
13  
14  
15  
16  
17  
18  
19  
20  
21  
22  
23  
24  
25  
26  
27  
28  
29  
30  
31  
32  
33  
34  
35  
36  
37  
38  
39  
40  
41  
42  
43  
44  
45  
46  
47  
48  
49  
</code></pre>
<p>| </p>
<pre><code>Matrixf4x4 operator+(const Matrixf4x4&amp; m) const {  
	Matrixf4x4 ans;  
	for (int i = 0; i &lt; 4; i++) {  
		for (int j = 0; j &lt; 4; j++) {  
			ans.m[i][j] = this-&gt;m[i][j] + m.m[i][j];  
		}  
	}  
	return ans;  
}  
  
template&lt;typename T&gt;  
Vector4&lt;T&gt; operator*(const Vector4&lt;T&gt;&amp; v) const {  
	return Vector4&lt;T&gt;(m[0][0] * v.x + m[0][1] * v.y + m[0][2] * v.z + m[0][3] * v.w,  
		m[1][0] * v.x + m[1][1] * v.y + m[1][2] * v.z + m[1][3] * v.w,  
		m[2][0] * v.x + m[2][1] * v.y + m[2][2] * v.z + m[2][3] * v.w,  
		m[3][0] * v.x + m[3][1] * v.y + m[3][2] * v.z + m[3][3] * v.w);  
}  
  
Matrixf4x4 operator*(const Matrixf4x4&amp; m) const {  
	Matrixf4x4 ans;  
	for (int i = 0; i &lt; 4; i++) {  
		for (int j = 0; j &lt; 4; j++) {  
			ans.m[i][j] = this-&gt;m[i][0] * m.m[0][j] +  
				this-&gt;m[i][1] * m.m[1][j] +  
				this-&gt;m[i][2] * m.m[2][j] +  
				this-&gt;m[i][3] * m.m[3][j];  
		}  
	}  
	return ans;  
}  
  
Matrixf4x4 operator*(float s) const {  
	Matrixf4x4 mat;  
	for (int i = 0; i &lt; 4; i++)  
	{  
		for (int j = 0; j &lt; 4; j++)  
		{  
			mat.m[i][j] = m[i][j] * s;  
		}  
	}  
	return mat;  
}  
  
friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const Matrixf4x4&amp; v) {  
	return os &lt;&lt; v.m[0][0] &lt;&lt; &quot; &quot; &lt;&lt; v.m[0][1] &lt;&lt; &quot; &quot; &lt;&lt; v.m[0][2] &lt;&lt; &quot; &quot; &lt;&lt; v.m[0][3] &lt;&lt; std::endl  
		&lt;&lt; v.m[1][0] &lt;&lt; &quot; &quot; &lt;&lt; v.m[1][1] &lt;&lt; &quot; &quot; &lt;&lt; v.m[1][2] &lt;&lt; &quot; &quot; &lt;&lt; v.m[1][3] &lt;&lt; std::endl  
		&lt;&lt; v.m[2][0] &lt;&lt; &quot; &quot; &lt;&lt; v.m[2][1] &lt;&lt; &quot; &quot; &lt;&lt; v.m[2][2] &lt;&lt; &quot; &quot; &lt;&lt; v.m[2][3] &lt;&lt; std::endl  
		&lt;&lt; v.m[3][0] &lt;&lt; &quot; &quot; &lt;&lt; v.m[3][1] &lt;&lt; &quot; &quot; &lt;&lt; v.m[3][2] &lt;&lt; &quot; &quot; &lt;&lt; v.m[3][3] &lt;&lt; std::endl;  
}  
  
</code></pre>
<p>—|—  </p>
<h3 id="矩阵的函数"><a href="#矩阵的函数" class="headerlink" title="矩阵的函数"></a>矩阵的函数</h3><p>我们需要设计几种矩阵的函数以供我们之后的工作使用。不过我们不可能把矩阵所有的运算都写出来，这就要求我们必须有所取舍。</p>
<p>我这里参考了DirectXMath库的方案，主要将会定义矩阵的转置、逆、行列式这几个用于计算的函数以及返回单位矩阵的函数。</p>
<h3 id="转置和返回单位矩阵"><a href="#转置和返回单位矩阵" class="headerlink" title="转置和返回单位矩阵"></a>转置和返回单位矩阵</h3><p>我们先从最简单的开始，转置无非就是把矩阵里的元素的行列下标对换：</p>
<pre><code>1  
2  
3  
4  
5  
6  
7  
</code></pre>
<p>| </p>
<pre><code>inline Matrixf4x4 Matrix4x4Transpose(const Matrixf4x4&amp; m) {  
	Matrixf4x4 mat(m.m[0][0], m.m[1][0], m.m[2][0], m.m[3][0],  
		m.m[0][1], m.m[1][1], m.m[2][1], m.m[3][1],  
		m.m[0][2], m.m[1][2], m.m[2][2], m.m[3][2],  
		m.m[0][3], m.m[1][3], m.m[2][3], m.m[3][3]);  
	return mat;  
}  
  
</code></pre>
<p>—|—  </p>
<p>似乎毫无难度。。。那买一送一再附赠一个吧</p>
<pre><code>1  
2  
3  
4  
</code></pre>
<p>| </p>
<pre><code>inline Matrixf4x4 Matrix4x4Identity() {  
	Matrixf4x4 m;  
	return m;  
}  
  
</code></pre>
<p>—|—  </p>
<h3 id="行列式"><a href="#行列式" class="headerlink" title="行列式"></a>行列式</h3><p>四阶矩阵的行列式比较复杂，如果是二阶或者三阶方阵，那我们很快就能给出结果，可惜我们现在需要硬写四阶方阵的行列式。</p>
<p>det[A11A12A13A14A21A22A23A24A31A32A33A34A41A42A43A44] &#x3D;A11det[A22A23A24A32A33A34A42A43A44] +A12det[A21A23A24A31A33A34A41A43A44] +A13det[A21A22A24A31A32A34A41A42A44] +A14det[A21A22A23A31A32A33A41A42A43] det\begin{bmatrix}A_{11}\quad A_{12}\quad A_{13}\quad A_{14}\\ A_{21\quad }A_{22}\quad A_{23}\quad A_{24}\\ A_{31\quad }A_{32}\quad A_{33}\quad A_{34}\\ A_{41\quad }A_{42}\quad A_{43}\quad A_{44} \end{bmatrix}\ &#x3D; A_{11}det\begin{bmatrix} A_{22}\quad A_{23}\quad A_{24}\\ A_{32}\quad A_{33}\quad A_{34}\\ A_{42}\quad A_{43}\quad A_{44} \end{bmatrix}\ \\+ A_{12}det\begin{bmatrix} A_{21}\quad A_{23}\quad A_{24}\\ A_{31}\quad A_{33}\quad A_{34}\\ A_{41}\quad A_{43}\quad A_{44} \end{bmatrix}\ + A_{13}det\begin{bmatrix} A_{21}\quad A_{22}\quad A_{24}\\ A_{31}\quad A_{32}\quad A_{34}\\ A_{41}\quad A_{42}\quad A_{44} \end{bmatrix}\ + A_{14}det\begin{bmatrix} A_{21}\quad A_{22}\quad A_{23}\\ A_{31}\quad A_{32}\quad A_{33}\\ A_{41}\quad A_{42}\quad A_{43} \end{bmatrix}\ det​A11​A12​A13​A14​A21​A22​A23​A24​A31​A32​A33​A34​A41​A42​A43​A44​​​ &#x3D;A11​det​A22​A23​A24​A32​A33​A34​A42​A43​A44​​​ +A12​det​A21​A23​A24​A31​A33​A34​A41​A43​A44​​​ +A13​det​A21​A22​A24​A31​A32​A34​A41​A42​A44​​​ +A14​det​A21​A22​A23​A31​A32​A33​A41​A42​A43​​​</p>
<p>而三阶方阵可以直接使用公式：</p>
<p>det[A11A12A13A21A22A23A31A32A33] &#x3D;A11A22A33+A12A23A31+A13A21A32−A13A22A31−A12A21A33−A11A23A32det\begin{bmatrix}A_{11}\quad A_{12}\quad A_{13}\\ A_{21\quad }A_{22}\quad A_{23}\\ A_{31\quad }A_{32}\quad A_{33}\\ \end{bmatrix}\ &#x3D; A_{11}A_{22}A_{33} + A_{12}A_{23}A_{31} + A_{13}A_{21}A_{32}- \\A_{13}A_{22}A_{31} - A_{12}A_{21}A_{33} - A_{11}A_{23}A_{32} det​A11​A12​A13​A21​A22​A23​A31​A32​A33​​​ &#x3D;A11​A22​A33​+A12​A23​A31​+A13​A21​A32​−A13​A22​A31​−A12​A21​A33​−A11​A23​A32​</p>
<p>然而我们并没有定义三阶方阵，为了拯救我们的键盘，只能临时赶紧定义一个：</p>
<pre><code>1  
2  
3  
4  
5  
6  
7  
8  
9  
10  
11  
12  
13  
14  
15  
16  
17  
18  
19  
20  
21  
22  
23  
24  
25  
26  
27  
28  
29  
30  
31  
32  
33  
34  
35  
36  
37  
38  
39  
40  
41  
42  
43  
44  
45  
46  
47  
48  
49  
50  
51  
52  
53  
54  
55  
56  
57  
58  
59  
60  
61  
62  
63  
64  
65  
66  
67  
68  
69  
70  
71  
72  
73  
74  
75  
76  
77  
78  
79  
80  
81  
82  
83  
</code></pre>
<p>| </p>
<pre><code>class Matrixf3x3 {  
public:  
	float m[3][3];  
	Matrixf3x3() {  
		m[0][0] = m[1][1] = m[2][2] = 1.f;  
		m[0][1] = m[0][2] =  
			m[1][0] = m[1][2] =  
			m[2][0] = m[2][1] = 0.f;  
	}  
	Matrixf3x3(float mat[3][3]) { memcpy(m, mat, 9 * sizeof(float)); }  
	Matrixf3x3(float t00, float t01, float t02,  
		float t10, float t11, float t12,  
		float t20, float t21, float t22)  
	{  
		m[0][0] = t00, m[0][1] = t01, m[0][2] = t02;  
		m[1][0] = t10, m[1][1] = t11, m[1][2] = t12;  
		m[2][0] = t20, m[2][1] = t21, m[2][2] = t22;  
	}  
   
       Matrixf3x3 operator+(const Matrixf3x3&amp; m) const {  
		Matrixf3x3 ans;  
		for (int i = 0; i &lt; 3; i++) {  
			for (int j = 0; j &lt; 3; j++) {  
				ans.m[i][j] = this-&gt;m[i][j] + m.m[i][j];  
			}  
		}  
		return ans;  
	}  
   
	template&lt;typename T&gt;  
	Matrixf3x3(Vector3&lt;T&gt; v0, Vector3&lt;T&gt; v1, Vector3&lt;T&gt; v2, Vector3&lt;T&gt; v3) {  
		m[0][0] = v0.x, m[0][1] = v1.x, m[0][2] = v2.x;  
		m[1][0] = v0.y, m[1][1] = v1.y, m[1][2] = v2.y;  
		m[2][0] = v0.z, m[2][1] = v1.z, m[2][2] = v2.z;  
	}  
  
	template&lt;typename T&gt;  
	Vector3&lt;T&gt; operator*(const Vector3&lt;T&gt;&amp; v) const {  
		return Vector3&lt;T&gt;(m[0][0] * v.x + m[0][1] * v.y + m[0][2] * v.z,  
			m[1][0] * v.x + m[1][1] * v.y + m[1][2] * v.z,  
			m[2][0] * v.x + m[2][1] * v.y + m[2][2] * v.z);  
	}  
  
	Matrixf3x3 operator*(const Matrixf3x3&amp; m) const {  
		Matrixf3x3 ans;  
		for (int i = 0; i &lt; 3; i++) {  
			for (int j = 0; j &lt; 3; j++) {  
				ans.m[i][j] = this-&gt;m[i][0] * m.m[0][j] +  
					this-&gt;m[i][1] * m.m[1][j] +  
					this-&gt;m[i][2] * m.m[2][j];  
			}  
		}  
		return ans;  
	}  
  
	Matrixf3x3 operator*(float s) const {  
		Matrixf3x3 mat;  
		for (int i = 0; i &lt; 3; i++)  
		{  
			for (int j = 0; j &lt; 3; j++)  
			{  
				mat.m[i][j] = m[i][j] * s;  
			}  
		}  
		return mat;  
	}  
  
	friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const Matrixf3x3&amp; v) {  
		return os &lt;&lt; v.m[0][0] &lt;&lt; &quot; &quot; &lt;&lt; v.m[0][1] &lt;&lt; &quot; &quot; &lt;&lt; v.m[0][2] &lt;&lt; std::endl  
			&lt;&lt; v.m[1][0] &lt;&lt; &quot; &quot; &lt;&lt; v.m[1][1] &lt;&lt; &quot; &quot; &lt;&lt; v.m[1][2] &lt;&lt; std::endl  
			&lt;&lt; v.m[2][0] &lt;&lt; &quot; &quot; &lt;&lt; v.m[2][1] &lt;&lt; &quot; &quot; &lt;&lt; v.m[2][2] &lt;&lt; std::endl;  
	}  
};  
  
inline float Matrix3x3Determinant(const Matrixf3x3&amp; m) {  
	return m.m[0][0] * m.m[1][1] * m.m[2][2] +  
		m.m[0][1] * m.m[1][2] * m.m[2][0] +  
		m.m[0][2] * m.m[1][0] * m.m[2][1] -  
		m.m[0][2] * m.m[1][1] * m.m[2][1] -  
		m.m[0][1] * m.m[1][0] * m.m[2][2] -  
		m.m[0][0] * m.m[1][2] * m.m[2][1];  
  
}  
  
</code></pre>
<p>—|—  </p>
<p>基本上都是复制粘贴，重点是最后那个行列式函数，有了这个三阶方阵的行列式函数，我们就可以轻松写出四阶的行列式函数。</p>
<p>但是先别急，我们再写一个函数用以返回4阶方阵的余子阵：</p>
<pre><code>1  
2  
3  
4  
5  
6  
7  
8  
9  
10  
11  
12  
13  
14  
15  
</code></pre>
<p>| </p>
<pre><code>inline Matrixf3x3 Matrix4x4CMinor(const Matrixf4x4&amp; mat, uint16_t row, uint16_t col) {  
	float m[3][3];  
	int m_row = 0;  
	for (int i = 0; i &lt; 4; i++) {  
		if (i == row) { continue; }  
		int m_col = 0;  
		for (int j = 0; j &lt; 4; j++) {  
			if (j == col) { continue; }  
			m[m_row][m_col] = mat.m[i][j];  
			m_col++;  
		}  
		m_row++;  
	}  
	return Matrixf3x3(m);  
}  
  
</code></pre>
<p>—|—  </p>
<p>然后我们就可以求矩阵的行列式了：</p>
<pre><code>1  
2  
3  
4  
5  
6  
</code></pre>
<p>| </p>
<pre><code>inline float Matrix4x4Determinant(const Matrixf4x4&amp; m) {  
	return m.m[0][0] * Matrix3x3Determinant(Matrix4x4CMinor(m, 0, 0)) +  
		m.m[0][1] * Matrix3x3Determinant(Matrix4x4CMinor(m, 0, 1)) +  
		m.m[0][2] * Matrix3x3Determinant(Matrix4x4CMinor(m, 0, 2)) +  
		m.m[0][3] * Matrix3x3Determinant(Matrix4x4CMinor(m, 0, 3));  
}  
  
</code></pre>
<p>—|—  </p>
<h3 id="逆"><a href="#逆" class="headerlink" title="逆"></a>逆</h3><p>终于到了最后一关，求矩阵的逆。</p>
<p>矩阵的逆有很多种求法，最基础的就是伴随矩阵除以行列式的求法。值得一提的是，pbrt-v3使用的是全主元消去法求矩阵逆，同时代码写的很好，我看了几遍下来没有发现它的算法有使用到额外空间来存储单位矩阵。</p>
<p>不过我们还是从最简单的伴随矩阵除以行列式的算法来做。</p>
<p>行列式已经解决了，让我们来看看伴随矩阵如何计算：</p>
<p>A∗&#x3D;CAT&#x3D;[C11C12C13C14C21C22C23C24C31C32C33C34C41C42C43C44]TA^*&#x3D;C^T_A&#x3D;\begin{bmatrix}C_{11}\quad C_{12}\quad C_{13}\quad C_{14}\\ C_{21\quad }C_{22}\quad C_{23}\quad C_{24}\\ C_{31\quad }C_{32}\quad C_{33}\quad C_{34}\\ C_{41\quad }C_{42}\quad C_{43}\quad C_{44} \end{bmatrix}^T A∗&#x3D;CAT​&#x3D;​C11​C12​C13​C14​C21​C22​C23​C24​C31​C32​C33​C34​C41​C42​C43​C44​​​T</p>
<p>Cij&#x3D;(−1)i+jdetA‾ijC_{ij}&#x3D;(-1)^{i+j}det\overline{A}_{ij} Cij​&#x3D;(−1)i+jdetAij​</p>
<p>这些公式所需要的转置函数和余子式函数都已经被我们写好了。可以说我们之前封装了那么多函数，就是为了这一刻：</p>
<pre><code>1  
2  
3  
4  
5  
6  
7  
8  
9  
10  
11  
12  
13  
</code></pre>
<p>| </p>
<pre><code>inline Matrixf4x4 Matrix4x4Inverse(const Matrixf4x4&amp; m) {  
	float DetM = Matrix4x4Determinant(m);  
	float InverseDetM = 1.0f / DetM;  
	Matrixf4x4 CofMat;  
	for (int i = 0; i &lt; 4; i++)  
	{  
		for (int j = 0; j &lt; 4; j++)  
		{  
			CofMat.m[i][j] = pow(-1, i + j) * Matrix3x3Determinant(Matrix4x4CMinor(m, i, j));  
		}  
	}  
	return Matrix4x4Transpose(CofMat * InverseDetM);  
}  
  
</code></pre>
<p>—|—  </p>
<p>好，到此为止，我自己测试了几个用例，结果都是正确的，那么我们这个数学库也就基本完成了，也就是说起码到了“可以用”的级别。</p>
<p>下一节我们将会开始MVP变换，届时将真正考验我们的数学库的正确性。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://chiuhoukazusa.github.io">Chiuhou</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://chiuhoukazusa.github.io/2022/09/15/02-%E7%AE%80%E5%8D%953D%E6%95%B0%E5%AD%A6%E5%BA%93%E5%B0%81%E8%A3%85%E5%90%91%E9%87%8F%E7%B1%BB%E5%92%8C%E7%9F%A9%E9%98%B5%E7%B1%BB/">https://chiuhoukazusa.github.io/2022/09/15/02-%E7%AE%80%E5%8D%953D%E6%95%B0%E5%AD%A6%E5%BA%93%E5%B0%81%E8%A3%85%E5%90%91%E9%87%8F%E7%B1%BB%E5%92%8C%E7%9F%A9%E9%98%B5%E7%B1%BB/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://chiuhoukazusa.github.io" target="_blank">Chiuhou 技术博客</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/chiuhou-tech-blog/tags/C/">C++</a><a class="post-meta__tags" href="/chiuhou-tech-blog/tags/%E5%9B%BE%E5%BD%A2%E5%AD%A6/">图形学</a></div><div class="post-share"><div class="social-share" data-image="/chiuhou-tech-blog/images/lianlian.jpg" data-sites="facebook,x,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/chiuhou-tech-blog/2022/09/23/03-HelloTrianglesMVP%E5%8F%98%E6%8D%A2/" title="03.HelloTriangles|MVP变换"><img class="cover" src="/chiuhou-tech-blog/images/Melina.png" onerror="onerror=null;src='/chiuhou-tech-blog/images/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">03.HelloTriangles|MVP变换</div></div><div class="info-2"><div class="info-item-1">03.HelloTriangles|MVP变换本项目代码已托管至github，将会随着博客实时更新进度每一节的工程我都会创建一个新的分支，分支名由这一节的数字决定。 https://github.com/chiuhoukazusa/LearningTinyrenderer/tree/03 前言在上一节中，我们实现了一个基本可用的3d数学库，我们马上就会使用到他们。 这一节中我们将实现渲染的第一个流程，MVP变换。这一节的目标就是实现games101的作业1的效果，我们将会传入跟101作业中一样的参数，并检验产生的三角形是否一致。 MVP变换并不是有了上一节的矩阵运算法则基础就一下子就可以讲清的，要理解MVP变换，要先了解矩阵与图形变换的关系。 本节引用的图片来自《Fundamentals of Computer Graphics Fifth Edition》和《Physically Based Rendering From Theorty To Implementation Third Edition》，下文将分别简述为虎书和PBRT-v3。 变换矩阵(Transformatio...</div></div></div></a><a class="pagination-related" href="/chiuhou-tech-blog/2022/08/09/01-%E4%B8%80%E5%88%87%E7%9A%84%E5%BC%80%E5%A7%8BBresenham%E7%AE%97%E6%B3%95%E7%BB%98%E5%88%B6%E7%BA%BF%E6%AE%B5/" title="01.一切的开始|Bresenham算法绘制线段"><img class="cover" src="/chiuhou-tech-blog/images/Maria.jpg" onerror="onerror=null;src='/chiuhou-tech-blog/images/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">01.一切的开始|Bresenham算法绘制线段</div></div><div class="info-2"><div class="info-item-1">01.一切的开始|Bresenham算法绘制线段本项目代码已托管至github，将会随着博客实时更新进度每一节的工程我都会创建一个新的分支，分支名由这一节的数字决定。 https://github.com/chiuhoukazusa/LearningTinyrenderer/tree/02 前言看着一片黑屏的渲染器和空空如也的cpp文件，我们可能无从下手，那就让我们回忆一下相关图形学知识。 我们都知道模型是由三角面构成的，三角面首先得有三角形，三角形又得有三条边。所以绘制线段就是我们要做的第一步。 绘制一条从(x0, y0)到(x1, y1)的线段因为我们是在像素上操作，所以我们就将传进来的这四个参数当做是int类型处理。 我们都知道直线拥有一个点斜式方程。 y&#x3D;kx+by &#x3D; kx + b y&#x3D;kx+b 我们能得到y的增量和x的增量之间的关系 △y&#x3D;k△x△y &#x3D; k△x △y&#x3D;k△x 那么我们让x每次增加一个像素的距离，这样每次△y就是一个固定的值，加上后让y再四舍五入到对应的像素点，把像素点画出来就行。 听起来很简...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/chiuhou-tech-blog/2022/10/16/04-%E5%9C%A8MVP%E4%B9%8B%E5%90%8E%E8%A3%81%E5%89%AA-%E4%B8%89%E8%A7%92%E5%BD%A2%E5%85%89%E6%A0%85%E5%8C%96%E4%B8%8E%E6%B7%B1%E5%BA%A6%E6%B5%8B%E8%AF%95-github/" title="04.在MVP之后|裁剪、三角形光栅化与深度测试"><img class="cover" src="/chiuhou-tech-blog/images/Maria.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2022-10-16</div><div class="info-item-2">04.在MVP之后|裁剪、三角形光栅化与深度测试</div></div><div class="info-2"><div class="info-item-1">04.在MVP之后|裁剪、三角形光栅化与深度测试本项目代码已托管至github，将会随着博客实时更新进度每一节的工程我都会创建一个新的分支，分支名由这一节的数字决定。 https://github.com/chiuhoukazusa/LearningTinyrenderer/tree/04 前言上一节中我们已经实现了一个简单的光栅化，但是这其实是完全不足够的，一个合理的三角形光栅化过程值得开一整节去叙述。 但这一节讲的将不仅仅是光栅化的过程，严格意义上讲，三角形光栅化基本上就是寻找三角形并且对一些属性插值的过程。但实际上图形渲染管线还有很多杂七杂八的步骤，我也将在这一节中进行讨论。 一般来说，MVP变换到光栅化，中间还应当有一个裁剪的步骤。而光栅化后就是着色，也是我们fragment shader工作的地方。着色后需要一个深度测试检测遮挡，用来判断哪些面是应该渲染的，当然着色后可能会有很多种不同的测试，但是我们这里先只讨论深度测试。 所有的测试都完成后会进入屏幕后处理阶段，可以做一些滤镜的效果，也可以做知名的RayMarching算法来构建诸如大气散射体积云等效果，当然也可以什么...</div></div></div></a><a class="pagination-related" href="/chiuhou-tech-blog/2023/01/18/05-%E8%BD%BD%E5%85%A53D%E6%A8%A1%E5%9E%8B%E6%A8%A1%E5%9E%8B%E5%8A%A0%E8%BD%BD%E4%B8%8E%E7%BA%B9%E7%90%86%E6%98%A0%E5%B0%84/" title="05.载入3D模型|模型加载、简单着色与纹理映射"><img class="cover" src="/chiuhou-tech-blog/images/lianlian.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-01-18</div><div class="info-item-2">05.载入3D模型|模型加载、简单着色与纹理映射</div></div><div class="info-2"><div class="info-item-1">05.载入3D模型|模型加载、简单着色与纹理映射本项目代码已托管至github，将会随着博客实时更新进度每一节的工程我都会创建一个新的分支，分支名由这一节的数字决定。 https://github.com/chiuhoukazusa/LearningTinyrenderer/tree/05 前言在上一节的工作完成后，我们离渲染出一个正常的三维模型还剩下两步，纹理映射和着色，当然前提是得先把模型给加载了。 这一节先来尝试纹理映射和简单着色模型。 上一节我们说过要引入一个读取obj的头文件，但我觉得完全可以自己写一个简单的objloader，那就不引入了吧。 OBJ-MTL文件格式obj是最广泛使用的3维模型的格式，实际上obj只是一个纯文本文件，我们可以梳理出他的大致结构。而mtl也是一个纯文本文件，基本上和obj对应，会记录一些材质信息。 我们以games202的吉祥物为例来理解一下obj和mtl文件的结构： 1   2   3   4   5   6   7   8   9   10   11   12   13   14   15   16   17   18   19   ...</div></div></div></a><a class="pagination-related" href="/chiuhou-tech-blog/2022/08/09/00-%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8%E4%B9%8B%E9%87%8D%E6%96%B0%E9%80%A0%E8%BD%AE%E5%AD%90%E8%BD%AF%E4%BB%B6%E5%85%89%E6%A0%85%E5%99%A8/" title="00.图形学入门之重新造轮子|软件光栅器"><img class="cover" src="/chiuhou-tech-blog/images/Melina.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2022-08-09</div><div class="info-item-2">00.图形学入门之重新造轮子|软件光栅器</div></div><div class="info-2"><div class="info-item-1">00.图形学入门之重新造轮子|软件光栅器“纸上得来终觉浅，绝知此事要躬行。”图形学的理论知识相当多，但终归还是要落到代码上来，毕竟这是一门工程性质的学科，想检验自己的理论知识就去实现它。 为什么要做软件光栅？图形学理论实践我认为在一头冲进opengl、dx11&#x2F;12、vulkan这些之前，我们可以先来关注一下这些图形api都是怎么运作的。同时我也刚学完了games101的课程，目前还没接触太多高质量实时渲染相关的知识。我认为在此之前先给自己101的课程来一个总结，来一个实践更容易巩固自己的相关知识基础，并且把自己在101的作业中实现的功能都尽量在自己的渲染器里实现一遍。 C++工程能力锻炼这个也许是更重要的原因。理论学的再多也只是理论，就像你在大学里可能会学建筑力学、结构力学、工程地质学等等理论，但是如果不去工地上真真切切地戴着安全帽打一打灰，你也不可能成为一个优秀的工程师。这在所有工科都是通用的经验。C++素以复杂、难学出名，如果不去真的在写代码，很容易陷入“看啥啥简单”的陷阱。我自己的C++水平也非常的不乐观，所以我决定在项目中锻炼锻炼C++。 我们的目标我目前的想...</div></div></div></a><a class="pagination-related" href="/chiuhou-tech-blog/2022/09/23/03-HelloTrianglesMVP%E5%8F%98%E6%8D%A2/" title="03.HelloTriangles|MVP变换"><img class="cover" src="/chiuhou-tech-blog/images/Melina.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2022-09-23</div><div class="info-item-2">03.HelloTriangles|MVP变换</div></div><div class="info-2"><div class="info-item-1">03.HelloTriangles|MVP变换本项目代码已托管至github，将会随着博客实时更新进度每一节的工程我都会创建一个新的分支，分支名由这一节的数字决定。 https://github.com/chiuhoukazusa/LearningTinyrenderer/tree/03 前言在上一节中，我们实现了一个基本可用的3d数学库，我们马上就会使用到他们。 这一节中我们将实现渲染的第一个流程，MVP变换。这一节的目标就是实现games101的作业1的效果，我们将会传入跟101作业中一样的参数，并检验产生的三角形是否一致。 MVP变换并不是有了上一节的矩阵运算法则基础就一下子就可以讲清的，要理解MVP变换，要先了解矩阵与图形变换的关系。 本节引用的图片来自《Fundamentals of Computer Graphics Fifth Edition》和《Physically Based Rendering From Theorty To Implementation Third Edition》，下文将分别简述为虎书和PBRT-v3。 变换矩阵(Transformatio...</div></div></div></a><a class="pagination-related" href="/chiuhou-tech-blog/2026/02/11/voronoi-diagram/" title="Voronoi 图生成器 - 计算几何的暴力之美"><img class="cover" src="https://raw.githubusercontent.com/chiuhoukazusa/blog_img/main/voronoi-2026-02-11/voronoi.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2026-02-11</div><div class="info-item-2">Voronoi 图生成器 - 计算几何的暴力之美</div></div><div class="info-2"><div class="info-item-1">Voronoi 图生成器 - 计算几何的暴力之美今天实现了经典的 Voronoi 图生成器，虽然使用暴力法（O(N×W×H)），但展示了计算几何的直观本质。 本项目代码已托管至 GitHub每日编程实践项目，记录每天的学习和实现。 https://github.com/chiuhoukazusa/daily-coding-practice/tree/main/2026/02/02-11-voronoi-generator  项目简介Voronoi 图是计算几何中非常重要的一种空间划分方法，将平面划分为若干个区域，每个区域内点到该区域对应的种子点的距离比到其他种子点更近。  开发时间: 约 13 分钟 代码量: 75 行 C++ 编译状态: ✅ 一次编译成功（0 错误，0 警告） 运行结果: ✅ 成功生成 800×600 像素的 Voronoi 图  技术要点Voronoi 图算法暴力法实现（Brute-force）： 1234567891011121314151617181920for (int y = 0; y &lt; height; y++) &#123;    for (...</div></div></div></a><a class="pagination-related" href="/chiuhou-tech-blog/2026/02/10/perlin-noise/" title="每日编程实践：Perlin 噪声程序化纹理生成"><img class="cover" src="https://raw.githubusercontent.com/chiuhoukazusa/blog_img/main/perlin_clouds.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2026-02-10</div><div class="info-item-2">每日编程实践：Perlin 噪声程序化纹理生成</div></div><div class="info-2"><div class="info-item-1">每日编程实践：Perlin 噪声程序化纹理生成🎯 项目概述在本项目中，我实现了一个经典的 Perlin 噪声生成器，用于创建自然的程序化纹理。Perlin 噪声由 Ken Perlin 于 1985 年发明，广泛应用于计算机图形学中的地形生成、云层模拟、水波效果等领域。 项目时间: 2026-02-10代码语言: C++代码行数: 230 行核心算法: Perlin Noise + Octave Noise Perlin 噪声原理Perlin 噪声通过以下步骤生成：  网格定义: 将空间划分为均匀的网格 梯度分配: 为每个网格点生成随机的梯度向量 平滑插值: 使用 fade 函数平滑插值网格点间的值 多层叠加: 通过 Octave Noise 添加多层次细节  核心数学实现Fade 函数（6t⁵ - 15t⁴ + 10t³）123double fade(double t) &#123;    return t * t * t * (t * (t * 6 - 15) + 10);&#125;  这个函数确保插值在网格边界处平滑过渡，避免出现明显的不连续性。 梯度计算123456d...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/chiuhou-tech-blog/images/Melina.png" onerror="this.onerror=null;this.src='/chiuhou-tech-blog/images/404.jpg'" alt="avatar"/></div><div class="author-info-name">Chiuhou</div><div class="author-info-description">记录编程学习和项目实践，专注图形学、算法与工程实践</div><div class="site-data"><a href="/chiuhou-tech-blog/archives/"><div class="headline">文章</div><div class="length-num">11</div></a><a href="/chiuhou-tech-blog/tags/"><div class="headline">标签</div><div class="length-num">13</div></a><a href="/chiuhou-tech-blog/categories/"><div class="headline">分类</div><div class="length-num">5</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#02-%E7%AE%80%E5%8D%953D%E6%95%B0%E5%AD%A6%E5%BA%93-%E5%B0%81%E8%A3%85%E5%90%91%E9%87%8F%E7%B1%BB%E5%92%8C%E7%9F%A9%E9%98%B5%E7%B1%BB"><span class="toc-number">1.</span> <span class="toc-text">02.简单3D数学库|封装向量类和矩阵类</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%AC%E9%A1%B9%E7%9B%AE%E4%BB%A3%E7%A0%81%E5%B7%B2%E6%89%98%E7%AE%A1%E8%87%B3github%EF%BC%8C%E5%B0%86%E4%BC%9A%E9%9A%8F%E7%9D%80%E5%8D%9A%E5%AE%A2%E5%AE%9E%E6%97%B6%E6%9B%B4%E6%96%B0%E8%BF%9B%E5%BA%A6"><span class="toc-number">1.1.</span> <span class="toc-text">本项目代码已托管至github，将会随着博客实时更新进度</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%89%8D%E8%A8%80"><span class="toc-number">1.2.</span> <span class="toc-text">前言</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%88%91%E4%BB%AC%E9%9C%80%E8%A6%81%E5%81%9A%E7%9A%84"><span class="toc-number">1.3.</span> <span class="toc-text">我们需要做的</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%90%91%E9%87%8F%EF%BC%88%E4%BB%A5Vector3%E4%B8%BA%E4%BE%8B%EF%BC%89"><span class="toc-number">1.4.</span> <span class="toc-text">向量（以Vector3为例）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%91%E9%87%8F%E7%9A%84%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD%E4%B8%8E%E5%87%BD%E6%95%B0"><span class="toc-number">1.4.1.</span> <span class="toc-text">向量的运算符重载与函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%94%B6%E5%B0%BE%E5%B7%A5%E4%BD%9C"><span class="toc-number">1.4.2.</span> <span class="toc-text">收尾工作</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9F%A9%E9%98%B5"><span class="toc-number">1.5.</span> <span class="toc-text">矩阵</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9F%A9%E9%98%B5%E7%9A%84%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD"><span class="toc-number">1.5.1.</span> <span class="toc-text">矩阵的运算符重载</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9F%A9%E9%98%B5%E7%9A%84%E5%87%BD%E6%95%B0"><span class="toc-number">1.5.2.</span> <span class="toc-text">矩阵的函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BD%AC%E7%BD%AE%E5%92%8C%E8%BF%94%E5%9B%9E%E5%8D%95%E4%BD%8D%E7%9F%A9%E9%98%B5"><span class="toc-number">1.5.3.</span> <span class="toc-text">转置和返回单位矩阵</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A1%8C%E5%88%97%E5%BC%8F"><span class="toc-number">1.5.4.</span> <span class="toc-text">行列式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%86"><span class="toc-number">1.5.5.</span> <span class="toc-text">逆</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/chiuhou-tech-blog/2026/02/15/daily-coding-cohen-sutherland-2026-02-15/" title="Cohen-Sutherland线段裁剪算法实现 - 图形学每日挑战"><img src="https://raw.githubusercontent.com/chiuhoukazusa/blog_img/main/cohen-sutherland-2026-02-15/output.png" onerror="this.onerror=null;this.src='/chiuhou-tech-blog/images/404.jpg'" alt="Cohen-Sutherland线段裁剪算法实现 - 图形学每日挑战"/></a><div class="content"><a class="title" href="/chiuhou-tech-blog/2026/02/15/daily-coding-cohen-sutherland-2026-02-15/" title="Cohen-Sutherland线段裁剪算法实现 - 图形学每日挑战">Cohen-Sutherland线段裁剪算法实现 - 图形学每日挑战</a><time datetime="2026-02-15T02:45:00.000Z" title="发表于 2026-02-15 10:45:00">2026-02-15</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/chiuhou-tech-blog/2026/02/14/daily-coding-bresenham-2026-02-14/" title="Bresenham直线绘制算法实践 - 图形学每日挑战"><img src="https://raw.githubusercontent.com/chiuhoukazusa/blog_img/main/bresenham-2026-02-14/bresenham_output.png" onerror="this.onerror=null;this.src='/chiuhou-tech-blog/images/404.jpg'" alt="Bresenham直线绘制算法实践 - 图形学每日挑战"/></a><div class="content"><a class="title" href="/chiuhou-tech-blog/2026/02/14/daily-coding-bresenham-2026-02-14/" title="Bresenham直线绘制算法实践 - 图形学每日挑战">Bresenham直线绘制算法实践 - 图形学每日挑战</a><time datetime="2026-02-14T02:00:00.000Z" title="发表于 2026-02-14 10:00:00">2026-02-14</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/chiuhou-tech-blog/2026/02/13/simple-ray-tracer-sphere-rendering/" title="每日编程实践：简单的光线追踪器渲染球体"><img src="https://raw.githubusercontent.com/chiuhoukazusa/blog_img/main/ray-tracer-2026-02-13/output.png" onerror="this.onerror=null;this.src='/chiuhou-tech-blog/images/404.jpg'" alt="每日编程实践：简单的光线追踪器渲染球体"/></a><div class="content"><a class="title" href="/chiuhou-tech-blog/2026/02/13/simple-ray-tracer-sphere-rendering/" title="每日编程实践：简单的光线追踪器渲染球体">每日编程实践：简单的光线追踪器渲染球体</a><time datetime="2026-02-13T02:00:00.000Z" title="发表于 2026-02-13 10:00:00">2026-02-13</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/chiuhou-tech-blog/2026/02/11/voronoi-diagram/" title="Voronoi 图生成器 - 计算几何的暴力之美"><img src="https://raw.githubusercontent.com/chiuhoukazusa/blog_img/main/voronoi-2026-02-11/voronoi.png" onerror="this.onerror=null;this.src='/chiuhou-tech-blog/images/404.jpg'" alt="Voronoi 图生成器 - 计算几何的暴力之美"/></a><div class="content"><a class="title" href="/chiuhou-tech-blog/2026/02/11/voronoi-diagram/" title="Voronoi 图生成器 - 计算几何的暴力之美">Voronoi 图生成器 - 计算几何的暴力之美</a><time datetime="2026-02-11T02:00:00.000Z" title="发表于 2026-02-11 10:00:00">2026-02-11</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/chiuhou-tech-blog/2026/02/10/perlin-noise/" title="每日编程实践：Perlin 噪声程序化纹理生成"><img src="https://raw.githubusercontent.com/chiuhoukazusa/blog_img/main/perlin_clouds.png" onerror="this.onerror=null;this.src='/chiuhou-tech-blog/images/404.jpg'" alt="每日编程实践：Perlin 噪声程序化纹理生成"/></a><div class="content"><a class="title" href="/chiuhou-tech-blog/2026/02/10/perlin-noise/" title="每日编程实践：Perlin 噪声程序化纹理生成">每日编程实践：Perlin 噪声程序化纹理生成</a><time datetime="2026-02-10T02:00:00.000Z" title="发表于 2026-02-10 10:00:00">2026-02-10</time></div></div></div></div></div></div></main><footer id="footer"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2025 - 2026 By Chiuhou</span><span class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 8.1.1</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.5.4</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/chiuhou-tech-blog/js/utils.js?v=5.5.4"></script><script src="/chiuhou-tech-blog/js/main.js?v=5.5.4"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>