<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>04.在MVP之后|裁剪、三角形光栅化与深度测试 | Chiuhou 技术博客</title><meta name="author" content="Chiuhou"><meta name="copyright" content="Chiuhou"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="04.在MVP之后|裁剪、三角形光栅化与深度测试本项目代码已托管至github，将会随着博客实时更新进度每一节的工程我都会创建一个新的分支，分支名由这一节的数字决定。 https:&#x2F;&#x2F;github.com&#x2F;chiuhoukazusa&#x2F;LearningTinyrenderer&#x2F;tree&#x2F;04 前言上一节中我们已经实现了一个简单的光栅化，但是这其实是完全不足够的，一个合理的三角形光栅化过程值得开一整节">
<meta property="og:type" content="article">
<meta property="og:title" content="04.在MVP之后|裁剪、三角形光栅化与深度测试">
<meta property="og:url" content="https://chiuhoukazusa.github.io/2022/10/16/04-%E5%9C%A8MVP%E4%B9%8B%E5%90%8E%E8%A3%81%E5%89%AA-%E4%B8%89%E8%A7%92%E5%BD%A2%E5%85%89%E6%A0%85%E5%8C%96%E4%B8%8E%E6%B7%B1%E5%BA%A6%E6%B5%8B%E8%AF%95-github/index.html">
<meta property="og:site_name" content="Chiuhou 技术博客">
<meta property="og:description" content="04.在MVP之后|裁剪、三角形光栅化与深度测试本项目代码已托管至github，将会随着博客实时更新进度每一节的工程我都会创建一个新的分支，分支名由这一节的数字决定。 https:&#x2F;&#x2F;github.com&#x2F;chiuhoukazusa&#x2F;LearningTinyrenderer&#x2F;tree&#x2F;04 前言上一节中我们已经实现了一个简单的光栅化，但是这其实是完全不足够的，一个合理的三角形光栅化过程值得开一整节">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://chiuhoukazusa.github.io/images/Melina.png">
<meta property="article:published_time" content="2022-10-15T20:41:00.000Z">
<meta property="article:modified_time" content="2026-02-10T08:51:00.734Z">
<meta property="article:author" content="Chiuhou">
<meta property="article:tag" content="C++">
<meta property="article:tag" content="图形学">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://chiuhoukazusa.github.io/images/Melina.png"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "04.在MVP之后|裁剪、三角形光栅化与深度测试",
  "url": "https://chiuhoukazusa.github.io/2022/10/16/04-%E5%9C%A8MVP%E4%B9%8B%E5%90%8E%E8%A3%81%E5%89%AA-%E4%B8%89%E8%A7%92%E5%BD%A2%E5%85%89%E6%A0%85%E5%8C%96%E4%B8%8E%E6%B7%B1%E5%BA%A6%E6%B5%8B%E8%AF%95-github/",
  "image": "https://chiuhoukazusa.github.io/images/Melina.png",
  "datePublished": "2022-10-15T20:41:00.000Z",
  "dateModified": "2026-02-10T08:51:00.734Z",
  "author": [
    {
      "@type": "Person",
      "name": "Chiuhou",
      "url": "https://chiuhoukazusa.github.io"
    }
  ]
}</script><link rel="shortcut icon" href="/chiuhou-tech-blog/images/favicon.png"><link rel="canonical" href="https://chiuhoukazusa.github.io/2022/10/16/04-%E5%9C%A8MVP%E4%B9%8B%E5%90%8E%E8%A3%81%E5%89%AA-%E4%B8%89%E8%A7%92%E5%BD%A2%E5%85%89%E6%A0%85%E5%8C%96%E4%B8%8E%E6%B7%B1%E5%BA%A6%E6%B5%8B%E8%AF%95-github/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/chiuhou-tech-blog/css/index.css?v=5.5.4"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@7.1.0/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/chiuhou-tech-blog/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.13.0/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '04.在MVP之后|裁剪、三角形光栅化与深度测试',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 8.1.1"></head><body><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(/chiuhou-tech-blog/images/Melina.png);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/chiuhou-tech-blog/"><span class="site-name">Chiuhou 技术博客</span></a><a class="nav-page-title" href="/chiuhou-tech-blog/"><span class="site-name">04.在MVP之后|裁剪、三角形光栅化与深度测试</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"></div></nav><div id="post-info"><h1 class="post-title">04.在MVP之后|裁剪、三角形光栅化与深度测试</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-10-15T20:41:00.000Z" title="发表于 2022-10-16 04:41:00">2022-10-16</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2026-02-10T08:51:00.734Z" title="更新于 2026-02-10 16:51:00">2026-02-10</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/chiuhou-tech-blog/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">学习笔记</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h1 id="04-在MVP之后-裁剪、三角形光栅化与深度测试"><a href="#04-在MVP之后-裁剪、三角形光栅化与深度测试" class="headerlink" title="04.在MVP之后|裁剪、三角形光栅化与深度测试"></a>04.在MVP之后|裁剪、三角形光栅化与深度测试</h1><h2 id="本项目代码已托管至github，将会随着博客实时更新进度"><a href="#本项目代码已托管至github，将会随着博客实时更新进度" class="headerlink" title="本项目代码已托管至github，将会随着博客实时更新进度"></a>本项目代码已托管至github，将会随着博客实时更新进度</h2><p>每一节的工程我都会创建一个新的分支，分支名由这一节的数字决定。</p>
<p><a target="_blank" rel="noopener" href="https://github.com/chiuhoukazusa/LearningTinyrenderer/tree/04">https://github.com/chiuhoukazusa/LearningTinyrenderer/tree/04</a></p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>上一节中我们已经实现了一个简单的光栅化，但是这其实是完全不足够的，一个合理的三角形光栅化过程值得开一整节去叙述。</p>
<p>但这一节讲的将不仅仅是光栅化的过程，严格意义上讲，三角形光栅化基本上就是寻找三角形并且对一些属性插值的过程。但实际上图形渲染管线还有很多杂七杂八的步骤，我也将在这一节中进行讨论。</p>
<p>一般来说，MVP变换到光栅化，中间还应当有一个裁剪的步骤。而光栅化后就是着色，也是我们fragment shader工作的地方。着色后需要一个深度测试检测遮挡，用来判断哪些面是应该渲染的，当然着色后可能会有很多种不同的测试，但是我们这里先只讨论深度测试。</p>
<p>所有的测试都完成后会进入屏幕后处理阶段，可以做一些滤镜的效果，也可以做知名的RayMarching算法来构建诸如大气散射体积云等效果，当然也可以什么都不做直接渲染出图像。</p>
<p>除此之外还需要一些简单的抗锯齿，而抗锯齿并不是一个固定的阶段，他可能发生在上述任何一个阶段，需要看具体算法而定。</p>
<p>其中，着色与屏幕后处理我们将在后续单独开新章节讲述，测试也许也会专门开章节吧。在这里我们将主要讲述的内容是裁剪、光栅化与深度测试。</p>
<h3 id="封装Vertex类"><a href="#封装Vertex类" class="headerlink" title="封装Vertex类"></a>封装Vertex类</h3><p>因为我们马上就会需要用到大量的插值算法，而每个顶点上存储的所有属性都将会被插值。</p>
<p>我们目前只是用到了法线颜色和坐标，我们后面马上就会引入深度和纹理坐标等属性，为了不让我们重复花费时间在给每个属性插值上面，我们先抽象一个vertex类：</p>
<pre><code>1  
2  
3  
4  
5  
6  
7  
8  
9  
10  
11  
12  
13  
14  
15  
16  
17  
18  
19  
20  
21  
22  
23  
24  
25  
26  
27  
28  
</code></pre>
<p>| </p>
<pre><code>#pragma once  
#include &quot;myEigen.hpp&quot;  
#include &quot;tgaimage.h&quot;  
  
namespace rst {  
	struct Vertex  
	{  
		myEigen::Vector4f vertex;  
		TGAColor vertexColor;  
		myEigen::Vector4f normal;  
  
		Vertex&amp; operator=(const Vertex&amp; v) {  
			vertex = v.vertex;  
			vertexColor = v.vertexColor;  
			normal = v.normal;  
			return *this;  
		}  
	};  
  
	inline Vertex lerp(const Vertex&amp; v1, const Vertex&amp; v2, const float t) {  
		return Vertex{  
			lerp(v1.vertex, v2.vertex, t),  
			ColorLerp(v1.vertexColor, v2.vertexColor, t),  
			lerp(v1.normal, v2.normal, t)  
		};  
	}  
}  
  
  
</code></pre>
<p>—|—  </p>
<p>可以看到我们这里用到了一个颜色的插值函数，原本的tgaimage.h里并没有这个函数，这是我自己加的：</p>
<pre><code>1  
2  
3  
4  
5  
6  
7  
8  
9  
10  
11  
12  
13  
14  
15  
16  
17  
18  
19  
20  
21  
22  
23  
24  
25  
</code></pre>
<p>| </p>
<pre><code>struct TGAColor {  
    std::uint8_t bgra[4] = { 0,0,0,0 };  
    std::uint8_t bytespp = { 0 };  
  
    TGAColor() = default;  
    TGAColor(const std::uint8_t R, const std::uint8_t G, const std::uint8_t B, const std::uint8_t A = 255) : bgra{ B,G,R,A }, bytespp(4) { }  
    TGAColor(const std::uint8_t* p, const std::uint8_t bpp) : bytespp(bpp) {  
        for (int i = bpp; i--; bgra[i] = p[i]);  
    }  
    std::uint8_t&amp; operator[](const int i) { return bgra[i]; }  
  
    inline TGAColor operator+(const TGAColor&amp; color) const {  
        return TGAColor(bgra[2] + color.bgra[2], bgra[1] + color.bgra[1], bgra[0] + color.bgra[0], bgra[3] + color.bgra[3]);  
    }  
    inline TGAColor operator*(const TGAColor&amp; color) const {  
        return TGAColor(bgra[2] * color.bgra[2], bgra[1] * color.bgra[1], bgra[0] * color.bgra[0], bgra[3] * color.bgra[3]);  
    }  
    inline TGAColor operator*(const float t) const {  
        return TGAColor(bgra[2] * t, bgra[1] * t, bgra[0] * t, bgra[3] * t);  
    }  
};  
  
inline TGAColor ColorLerp(const TGAColor&amp; color1, const TGAColor&amp; color2, float t) {  
    return color1 * (1 - t) + color2 * t;  
}  
  
</code></pre>
<p>—|—  </p>
<p>注意TGAColor类里存储的是bgra而非rgba，不要写反了。</p>
<p>基本上就这样就差不多了，记得修改下三角形类里的成员，都改成新的vertex类。</p>
<p>这样我们后续想给顶点添加属性只需要在这个类里修改就可以。</p>
<h2 id="在光栅化之前"><a href="#在光栅化之前" class="headerlink" title="在光栅化之前"></a>在光栅化之前</h2><p>在上一节的MVP变换中，其实我们的处理是有一些问题的的，但是我们选择的测试用例并没有暴露出这些问题。</p>
<p>简单来说我们一直强调只有视椎体、正交视体或者是正交投影后的正则视体才可以被渲染，但是我们并没有实质上做剔除或者是裁剪操作，在最后的正则视体空间内，我们将坐标的xy映射到屏幕空间的对应坐标后，并没有对z值操作就直接就光栅化了坐标点。这样虽然正则视体x方向和y方向上的物体确确实实被排除了（被映射到了不属于屏幕空间范围内的坐标），但是近裁剪平面跟远裁剪平面以外的物体并没有被剔除或者裁剪，还是会被渲染到屏幕空间上。</p>
<p>所以我们现在最需要做的就是裁剪与剔除：</p>
<h3 id="裁剪-Clip-与剔除-Cull"><a href="#裁剪-Clip-与剔除-Cull" class="headerlink" title="裁剪(Clip)与剔除(Cull)"></a>裁剪(Clip)与剔除(Cull)</h3><h5 id="注意：我们现在模拟的阶段对应的是GPU渲染管线上的裁剪，而非应用程序阶段的视椎体剔除。一般来说，物体在从cpu发送到gpu之前，我们会先在cpu内对每个物体造一个包围盒，再用包围盒跟视椎体进行计算，剔除那些包围盒都不跟视椎体有任何交叉的物体以减少draw-call，而gpu端的剔除粒度更细，面对的对象是那些构成物体的图元。"><a href="#注意：我们现在模拟的阶段对应的是GPU渲染管线上的裁剪，而非应用程序阶段的视椎体剔除。一般来说，物体在从cpu发送到gpu之前，我们会先在cpu内对每个物体造一个包围盒，再用包围盒跟视椎体进行计算，剔除那些包围盒都不跟视椎体有任何交叉的物体以减少draw-call，而gpu端的剔除粒度更细，面对的对象是那些构成物体的图元。" class="headerlink" title="注意：我们现在模拟的阶段对应的是GPU渲染管线上的裁剪，而非应用程序阶段的视椎体剔除。一般来说，物体在从cpu发送到gpu之前，我们会先在cpu内对每个物体造一个包围盒，再用包围盒跟视椎体进行计算，剔除那些包围盒都不跟视椎体有任何交叉的物体以减少draw call，而gpu端的剔除粒度更细，面对的对象是那些构成物体的图元。"></a>注意：我们现在模拟的阶段对应的是GPU渲染管线上的裁剪，而非应用程序阶段的视椎体剔除。一般来说，物体在从cpu发送到gpu之前，我们会先在cpu内对每个物体造一个包围盒，再用包围盒跟视椎体进行计算，剔除那些包围盒都不跟视椎体有任何交叉的物体以减少draw call，而gpu端的剔除粒度更细，面对的对象是那些构成物体的图元。</h5><p>注意区分裁剪与剔除这两个概念，剔除指的是将一个三角形，或者更准确地说一个图元完全删去。比如完全不在我们的视椎体内的三角形图元，或者物体背面的三角形图元需要被剔除。但是裁剪特指对于那些一部分在视体外，一部分在视体内的那种图元，我们需要对它们进行“裁剪”。</p>
<p>不过其实混用这两个概念应该也没事。。。大家应该都知道彼此在说什么。</p>
<p>裁剪与剔除其实是与MVP变换高度关联的步骤，也可以把这一小章节当做是对于上一节的补充。</p>
<p>虽然说裁剪与剔除看似只是为了加速我们的渲染流程，但实际上如果完全不做裁剪，我们渲染的图像肯定会出错误。大家回忆一下这玩意儿：</p>
<p>P[xyz1]&#x3D;[nxny(n+f)z−fnz]&#x3D;&gt;[nxznyzn+f−fnz1]P\begin{bmatrix}x\\y\\z\\1\end{bmatrix}&#x3D; \begin{bmatrix}nx\\ny\\(n+f)z-fn\\z\end{bmatrix}&#x3D;&gt; \begin{bmatrix}\frac{nx}{z}\\\frac{ny}{z}\\n+f-\frac{fn}{z}\\1\end{bmatrix} P​xyz1​​&#x3D;​nxny(n+f)z−fnz​​&#x3D;&gt;​znx​zny​n+f−zfn​1​​</p>
<p>可以看出z在透视矩阵变换后变成了一个反比例函数，而x和y则乘以n再除以z，这意味着</p>
<p>1.z为0的时候计算会出错误。</p>
<p>2.n为0时会丢失所有坐标信息。</p>
<p>3.反比例函数则意味着位于摄像机后面的物体的z坐标反而被映射到了一个比摄像机前物体z坐标区间更小的区间，摄像机背后的物体也会被渲染出来。</p>
<p>对于2，我们只需要规定近裁剪平面不能与相机重合就行，最起码也得跟相机有那么一点距离，就像unity里的near clip plane最小值不能为0一样。</p>
<p>而对于1和3，我们只能通过裁剪那些近平面后的图元才能做到正确渲染想要的图像。</p>
<p>对于3发生的原因我们马上就会讨论到。</p>
<h4 id="裁剪位于渲染管线的位置"><a href="#裁剪位于渲染管线的位置" class="headerlink" title="裁剪位于渲染管线的位置"></a>裁剪位于渲染管线的位置</h4><p>现在最广泛运用的应该就是齐次坐标裁剪。</p>
<p>这个名词可能有些让人困惑，这就不得不提MVP变换中被我们一笔带过的那个过程了。</p>
<p>我们之前说过，透视投影矩阵会导致坐标的w变成了变换前的z值，想要继续走下一步需要先把坐标每项都除以w，也就是做“透视除法”。</p>
<p>但这里有大学问，做透视除法前的坐标可以看到是一个不折不扣的四维坐标，而它所在的空间被我们称作齐次裁剪空间，或者裁剪空间。我们所说的齐次坐标裁剪也就是在这个空间内进行。当裁剪完毕后，我们才会做透视除法，将空间转换为我们之前说的正则视体，或者简写称作CVV(canonical view volume)，而CVV所在的坐标被我们称作NDC(normalized device coordinates)，也就是归一化设备坐标。注意透视除法并没有把我们的空间变换到哪个新空间，只是变换到了归一化设备坐标系上。</p>
<p>那么是不是我们在裁剪空间就能一下裁剪完所有三角形呢？</p>
<p>应该也可以，但是判断一个三角形和一个box的裁剪非常复杂，比方说想象一个三角形三个顶点都在立方体外，却从中间穿过了立方体的情况，我们应该如何判断呢？</p>
<p>所以我在我的光栅器中简化问题，在齐次空间只做近远平面的裁剪，在屏幕空间再裁剪那些经过映射后跑出屏幕外的顶点。</p>
<p>所以我们先把渲染管线的顺序给分清：</p>
<pre><code>1  
2  
3  
4  
5  
6  
7  
8  
9  
10  
11  
12  
13  
14  
15  
16  
17  
18  
19  
20  
21  
22  
23  
24  
25  
26  
27  
28  
29  
30  
31  
32  
33  
34  
35  
36  
37  
38  
39  
40  
41  
42  
43  
44  
45  
46  
47  
48  
49  
50  
51  
52  
53  
54  
55  
56  
57  
58  
59  
60  
61  
62  
63  
64  
65  
66  
67  
68  
69  
70  
71  
72  
73  
74  
75  
76  
</code></pre>
<p>| </p>
<pre><code>void rasterizer::draw(std::vector&lt;std::shared_ptr&lt;rst::Triangle&gt;&gt;&amp; TriangleList)  
{  
	Transform projection = Perspective(zneardis, zfardis, fovY, aspect);  
	Transform  mv = Camera(eye_pos, gaze_dir, view_up) * Modeling(myEigen::Vector3f(0),  
		myEigen::Vector3f(1),  
		myEigen::Vector3f(rotateAxis), theta);  
	Transform viewport = Viewport(width, height);  
  
	for (const auto&amp; t : TriangleList)  
	{  
		Triangle NewTriangle = *t;  
  
		//Model Space -&gt; World Space -&gt; Camera Space  
		std::array&lt;myEigen::Vector4f, 3&gt; vert  
		{  
			(mv(t-&gt;vertex[0].vertex)),  
			(mv(t-&gt;vertex[1].vertex)),  
			(mv(t-&gt;vertex[2].vertex))  
		};  
		auto cameraSpacePos = vert;  
  
		//BackCulling  
		if (backCulling) {  
  
		}  
  
		//Transform Normal  
		auto normalMV = mv;  
		normalMV.toNormal();  
		std::array&lt;myEigen::Vector4f, 3&gt; normal  
		{  
			(normalMV(t-&gt;vertex[0].normal)),  
			(normalMV(t-&gt;vertex[1].normal)),  
			(normalMV(t-&gt;vertex[2].normal))  
		};  
  
		//Camera Space -&gt; Homogeneous Clipping Space  
		for (auto&amp; v : vert)  
		{  
			v = projection(v);  
		}  
  
		//Homogeneous Clipping   
		for (auto&amp; v : vert)  
		{  
	  
		}  
  
		//Homogeneous Clipping Space -&gt; Canonical View Volume(CVV)  
		for (auto&amp; v : vert)  
		{  
			v /= v.w;  
		}  
  
		//Canonical View Volume(CVV) -&gt; Screen Space  
		for (auto&amp; v : vert)  
		{  
			v = viewport(v);  
		}  
  
		for (size_t i = 0; i &lt; 3; i++)  
		{  
			NewTriangle.setVertexPos(i, vert[i]);  
			NewTriangle.setColor(i, t-&gt;vertex[i].vertexColor);  
			NewTriangle.setNormal(i, normal[i]);  
		}  
  
		//Viewport Clipping  
		auto NewVert = clip_Cohen_Sutherland(NewTriangle, cameraSpacePos);  
  
		for (size_t i = 0; i &lt; NewVert.size() - 2; i++)  
		{  
			rasterize_edge_walking(Triangle(NewVert[0], NewVert[1 + i], NewVert[2 + i]), cameraSpacePos);  
		}  
	}  
}  
  
</code></pre>
<p>—|—  </p>
<h4 id="为什么不在CVV内做裁剪？"><a href="#为什么不在CVV内做裁剪？" class="headerlink" title="为什么不在CVV内做裁剪？"></a>为什么不在CVV内做裁剪？</h4><p>经过上述的讲解，很容易想到的就是我们可以在NDC下对CVV进行裁剪，毕竟CVV是正则视体嘛，一个立方体想做些计算想想就很容易。</p>
<p>但是可惜的是不行。</p>
<p>做透视除法前，我们的z坐标变换前与变换后还是一个简单的线性关系：</p>
<p>z′&#x3D;(n+f)z−fnz^{‘}&#x3D;(n+f)z-fn z′&#x3D;(n+f)z−fn</p>
<p>但是做了透视除法后一切都不一样了，他们变成了一个反比例函数的关系：</p>
<p>z′&#x3D;n+f−fnzz^{‘}&#x3D;n+f-\frac{fn}{z} z′&#x3D;n+f−zfn​</p>
<p>这个过程使得我们之前说的问题3被暴露了出来，感兴趣的可以画画函数曲线，其中n和f都小于0。</p>
<p>画了函数曲线的话就可以看出，位于摄像机后面的物体的z坐标反而被映射到了一个比摄像机前物体z坐标区间更小的区间里，这给我们的裁剪算法反而带来了更多的麻烦，所以我们选择齐次坐标裁剪。</p>
<h4 id="齐次坐标裁剪"><a href="#齐次坐标裁剪" class="headerlink" title="齐次坐标裁剪"></a>齐次坐标裁剪</h4><h5 id="我的软件光栅器中齐次坐标裁剪的方式仅供参考，并不代表实际的GPU是怎么处理裁剪系统的。实际的GPU应该只会严格裁剪近远平面的图元来确保光栅化结果正确，而对于屏幕空间即xy平面上，GPU会给一个比我们屏幕空间大得多的矩形来做裁剪判断，这样除非是越界得特别过分的图元，不然不会被裁剪。对于GPU来说，做一些复杂的裁剪算法，还不如让它用蛮力多算几个像素来的快。"><a href="#我的软件光栅器中齐次坐标裁剪的方式仅供参考，并不代表实际的GPU是怎么处理裁剪系统的。实际的GPU应该只会严格裁剪近远平面的图元来确保光栅化结果正确，而对于屏幕空间即xy平面上，GPU会给一个比我们屏幕空间大得多的矩形来做裁剪判断，这样除非是越界得特别过分的图元，不然不会被裁剪。对于GPU来说，做一些复杂的裁剪算法，还不如让它用蛮力多算几个像素来的快。" class="headerlink" title="我的软件光栅器中齐次坐标裁剪的方式仅供参考，并不代表实际的GPU是怎么处理裁剪系统的。实际的GPU应该只会严格裁剪近远平面的图元来确保光栅化结果正确，而对于屏幕空间即xy平面上，GPU会给一个比我们屏幕空间大得多的矩形来做裁剪判断，这样除非是越界得特别过分的图元，不然不会被裁剪。对于GPU来说，做一些复杂的裁剪算法，还不如让它用蛮力多算几个像素来的快。"></a>我的软件光栅器中齐次坐标裁剪的方式仅供参考，并不代表实际的GPU是怎么处理裁剪系统的。实际的GPU应该只会严格裁剪近远平面的图元来确保光栅化结果正确，而对于屏幕空间即xy平面上，GPU会给一个比我们屏幕空间大得多的矩形来做裁剪判断，这样除非是越界得特别过分的图元，不然不会被裁剪。对于GPU来说，做一些复杂的裁剪算法，还不如让它用蛮力多算几个像素来的快。</h5><p>齐次裁剪空间其实是一个四维空间，比较不太容易想象。但是我们可以通过这个式子来大致想象一下</p>
<p>P[xyz1]&#x3D;[nxny(n+f)z−fnz]&#x3D;&gt;[nxznyzn+f−fnz1]P\begin{bmatrix}x\\y\\z\\1\end{bmatrix}&#x3D; \begin{bmatrix}nx\\ny\\(n+f)z-fn\\z\end{bmatrix}&#x3D;&gt; \begin{bmatrix}\frac{nx}{z}\\\frac{ny}{z}\\n+f-\frac{fn}{z}\\1\end{bmatrix} P​xyz1​​&#x3D;​nxny(n+f)z−fnz​​&#x3D;&gt;​znx​zny​n+f−zfn​1​​</p>
<p>因为我们所要得到的透视除法后的空间是CVV，是一个xyz区间皆在[-1, 1]内的正则立方体，我们可以反推得出x，y，z各自的取值范围：</p>
<p>−∣w∣&lt;nx&lt;∣w∣−∣w∣&lt;ny&lt;∣w∣f&lt;w&lt;n-|w|&lt;nx&lt;|w|\\ -|w|&lt;ny&lt;|w|\\ f&lt;w&lt;n −∣w∣&lt;nx&lt;∣w∣−∣w∣&lt;ny&lt;∣w∣f&lt;w&lt;n</p>
<p>其中w为物体透视变换前的z值。而变换前的z值显然需要在近远平面区间内，所以直接得出w的取值范围。（别忘了n和f都是负值）</p>
<p>既然是不等式，那么w的取值范围非常重要，w必须确定是负值还是正值，不然得出的式子肯定不一样，所以我们在这个阶段需要做的就是近远平面的裁剪，将w锁定在负值上。</p>
<pre><code>1  
2  
3  
4  
5  
</code></pre>
<p>| </p>
<pre><code>//Homogeneous Clipping   
for (auto&amp; v : vert)  
{  
	if (v.w &gt; -zneardis || v.w &lt; -zfardis) continue;  
}  
  
</code></pre>
<p>—|—  </p>
<h4 id="Cohen-Sutherland算法"><a href="#Cohen-Sutherland算法" class="headerlink" title="Cohen-Sutherland算法"></a>Cohen-Sutherland算法</h4><h5 id="三角形的裁剪-线段的裁剪-顶点的裁剪"><a href="#三角形的裁剪-线段的裁剪-顶点的裁剪" class="headerlink" title="三角形的裁剪-&gt;线段的裁剪-&gt;顶点的裁剪"></a>三角形的裁剪-&gt;线段的裁剪-&gt;顶点的裁剪</h5><p>我们接着在屏幕空间处理那些超出屏幕的三角形，这里我们会用到编码裁剪算法</p>
<p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E7%A7%91%E6%81%A9%EF%BC%8D%E8%8B%8F%E6%B3%BD%E5%85%B0%E7%AE%97%E6%B3%95">科恩－苏泽兰算法 - 维基百科，自由的百科全书 (wikipedia.org)</a></p>
<p>可以参考一下这个算法的内容，wiki里的介绍写的非常好，我建议直接看他的原文：</p>
<p><img src="https://raw.githubusercontent.com/chiuhoukazusa/blog_img/main/202210160409207.png" alt="Cohen-Sutherland"></p>
<p>需要注意的是，这个裁剪需要对边，也就是线段进行裁剪，而我们三角形使用的是顶点来表示，我们定义一下线段类：</p>
<pre><code>1  
2  
3  
4  
5  
6  
7  
8  
9  
</code></pre>
<p>| </p>
<pre><code>struct Line  
{  
	Vertex v1;  
	Vertex v2;  
	bool isNull = false;  
  
	Line() :isNull(true){}  
	Line(const Vertex&amp; v1, const Vertex&amp; v2) :v1(v1), v2(v2) {}  
};  
  
</code></pre>
<p>—|—  </p>
<p>我们照着一步一步来：</p>
<p>首先我们将三角形化成三个线段，并在clip_line函数里对每条线段的两个顶点进行编码</p>
<p><img src="https://raw.githubusercontent.com/chiuhoukazusa/blog_img/main/202210160409332.png" alt="Cohen-Sutherland_img2"></p>
<pre><code>1  
2  
3  
4  
5  
6  
7  
8  
9  
10  
11  
12  
13  
14  
15  
16  
17  
18  
19  
20  
21  
22  
23  
24  
25  
26  
27  
28  
29  
30  
31  
32  
33  
34  
35  
36  
37  
38  
</code></pre>
<p>| </p>
<pre><code>std::vector&lt;myEigen::Vector4f&gt; rasterizer::clip_Cohen_Sutherland(const Triangle&amp; t)  
{  
	auto v = t.vertex;  
  
	std::array&lt;Line, 3&gt; line  
	{  
		Line(v[0], v[1]),  
		Line(v[1], v[2]),  
		Line(v[2], v[0])  
	};  
  
	line[0] = clip_line(line[0]);  
	line[1] = clip_line(line[1]);  
	line[2] = clip_line(line[2]);  
}  
Line rasterizer::clip_line(const Line&amp; line)  
{  
	Vertex v[2];  
	v[0] = line.v1, v[1] = line.v2;  
	int code[2];  
	code[0] = 0, code[1] = 0;  
	const int left = 1;  
	const int right = 2;  
	const int bottom = 4;  
	const int top = 8;  
  
	for (size_t i = 0; i &lt; 2; i++)  
	{  
		if (v[i].vertex.x &lt; 0) code[i] = code[i] | 1;  
		if (v[i].vertex.x &gt; width) code[i] = code[i] | 2;  
		if (v[i].vertex.y &lt; 0) code[i] = code[i] | 4;  
		if (v[i].vertex.y &gt; height) code[i] = code[i] | 8;  
	}  
  
       ...  
         
	return Line(v[0], v[1]);  
}  
  
</code></pre>
<p>—|—  </p>
<p>然后观察这个空间的编码结果来看看怎么对顶点进行裁剪：</p>
<p><img src="https://raw.githubusercontent.com/chiuhoukazusa/blog_img/main/202210160409427.png" alt="Cohen-Sutherland_img1"></p>
<p>很显然如果一条线段的两个顶点在同一侧，那么编码上总会有一个数字是相同的，即按位与运算结果不为0，这条线段将被丢弃。</p>
<p>否则将顶点与0001(左)，0010(右), 0100(下), 1000(上)做按位与运算，结果不为零就说明在哪一个区域，我们将插值出新的顶点。</p>
<p>因为我们已经排除了两个顶点在同一侧的情况，所以如果顶点在左侧，那么另一个顶点一定在他右边，且我们可以直接求出插值权重weight&#x3D;（左边界x - 左顶点x）&#x2F;（右边界x-左边界x）来计算裁剪后的新顶点。</p>
<p>对于其他区域同理。</p>
<p>我们需要构建一个while大循环来给每一个顶点的两个坐标都进行类似的裁剪，while的退出条件即为两个顶点最终都被裁剪到0000这个区域内或者两个顶点在同一侧，所以循环中的clip_vert函数我们需要实时对编码进行更新：</p>
<pre><code>1  
2  
3  
4  
5  
6  
7  
8  
9  
10  
11  
12  
13  
14  
15  
16  
17  
18  
19  
20  
21  
22  
23  
24  
25  
26  
27  
28  
29  
30  
31  
</code></pre>
<p>| </p>
<pre><code>Line rasterizer::clip_line(const Line&amp; line,  
	const std::array&lt;myEigen::Vector4f, 2&gt;&amp; clipSpacePos)  
{  
	Vertex v[2];  
	v[0] = line.v1, v[1] = line.v2;  
	int code[2];  
	code[0] = 0, code[1] = 0;  
	const int left = 1;  
	const int right = 2;  
	const int bottom = 4;  
	const int top = 8;  
  
	auto vert1 = v[0];  
	auto vert2 = v[1];  
  
	for (size_t i = 0; i &lt; 2; i++)  
	{  
		if (v[i].vertex.x &lt; 0) code[i] = code[i] | 1;  
		if (v[i].vertex.x &gt; width) code[i] = code[i] | 2;  
		if (v[i].vertex.y &lt; 0) code[i] = code[i] | 4;  
		if (v[i].vertex.y &gt; height) code[i] = code[i] | 8;  
	}  
  
	while (code[0] != 0 || code[1] != 0)  
	{  
		if ((code[0] &amp; code[1]) != 0) return Line();  
		vert1 = clip_vert(vert1, vert2, code[0], code[1], 0, width, 0, height, { clipSpacePos[0], clipSpacePos[1] });  
		vert2 = clip_vert(vert2, vert1, code[1], code[0], 0, width, 0, height, { clipSpacePos[1], clipSpacePos[0] });  
	}  
	return Line(vert1, vert2);  
}  
  
</code></pre>
<p>—|—  </p>
<p>然后我们来着手实现这个clip_vert函数对顶点进行裁剪并且实时更新编码值。</p>
<p>需要注意的是，我们的顶点经过裁剪后都是落到边界直线上，但是我们更新编码值的方法并没有界定落到边上的顶点如何给定编码，那么我们该怎么做呢？</p>
<p>解决方案很简单，我们以这条线段为例。</p>
<p><img src="https://raw.githubusercontent.com/chiuhoukazusa/blog_img/main/202210160409527.png" alt="Cohen-Sutherland_img1"></p>
<p>这条线段两个顶点不在同一侧，所以不会被提前删掉，进入第一次顶点裁剪。</p>
<p>先对（x1，y1）进行左裁剪，裁剪后落到左边界这条直线上，我们可以给x坐标加0.001，他就进入了1000区域，而不是落在便捷上了。</p>
<p>那么在下一次循环中这两个顶点就会落到同一侧，while循环就会结束，并返回一条空线段。</p>
<pre><code>1  
2  
3  
4  
5  
6  
7  
8  
9  
10  
11  
12  
13  
14  
15  
16  
17  
18  
19  
20  
21  
22  
23  
24  
25  
26  
27  
28  
29  
30  
31  
32  
33  
34  
35  
36  
37  
38  
39  
40  
41  
42  
43  
44  
45  
46  
47  
48  
</code></pre>
<p>| </p>
<pre><code>static Vertex clip_vert(const Vertex&amp; _v1, const Vertex&amp; _v2, int&amp; code1, const int&amp; code2,  
	const int leftBound, const int rightBound, const int bottomBound, const int topBound,   
	const std::array&lt;myEigen::Vector4f, 2&gt;&amp; clipSpacePos)  
{  
	const int left = 1;  
	const int right = 2;  
	const int bottom = 4;  
	const int top = 8;  
  
	auto v1 = _v1;  
	auto&amp; v2 = _v2;  
	if ((left &amp; code1) != 0)  
	{  
		float lerpNumber = (leftBound - v1.vertex.x) / (v2.vertex.x - v1.vertex.x);  
		v1 = perspectiveLerp(_v1, _v2, lerpNumber, clipSpacePos[0], clipSpacePos[1]);  
		v1.vertex = lerp(_v1.vertex, _v2.vertex, lerpNumber);  
		v1.vertex.x += 0.001f;  
	}  
	else if ((right &amp; code1) != 0)  
	{  
		float lerpNumber = (v1.vertex.x - rightBound) / (v1.vertex.x - v2.vertex.x);  
		v1 = perspectiveLerp(_v1, _v2, lerpNumber, clipSpacePos[0], clipSpacePos[1]);  
		v1.vertex = lerp(_v1.vertex, _v2.vertex, lerpNumber);  
		v1.vertex.x -= 0.001f;  
	}  
	else if ((bottom &amp; code1) != 0)  
	{  
		float lerpNumber = (bottomBound - v1.vertex.y) / (v2.vertex.y - v1.vertex.y);  
		v1 = perspectiveLerp(_v1, _v2, lerpNumber, clipSpacePos[0], clipSpacePos[1]);  
		v1.vertex = lerp(_v1.vertex, _v2.vertex, lerpNumber);  
		v1.vertex.y += 0.001f;  
	}  
	else if ((top &amp; code1) != 0)  
	{  
		float lerpNumber = (v1.vertex.y - topBound) / (v1.vertex.y - v2.vertex.y);  
		v1 = perspectiveLerp(_v1, _v2, lerpNumber, clipSpacePos[0], clipSpacePos[1]);  
		v1.vertex = lerp(_v1.vertex, _v2.vertex, lerpNumber);  
		v1.vertex.y -= 0.001f;  
	}  
  
	code1 = 0;  
	if (v1.vertex.x &lt; leftBound) code1 = (code1 | left);  
	if (v1.vertex.x &gt; rightBound) code1 = (code1 | right);  
	if (v1.vertex.y &lt; bottomBound) code1 = (code1 | bottom);  
	if (v1.vertex.y &gt; topBound) code1 = (code1 | top);  
  
	return v1;  
}  
  
</code></pre>
<p>—|—  </p>
<p>注意一下我们用到的这个插值函数不是我们之前定义的lerp函数，这是因为如果在屏幕空间上对三维或者四维空间中的三角形进行插值的时候需要做透视矫正。</p>
<p>若想详细了解，请往下翻到透视矫正这一小节。</p>
<p>我们的顶点和线段裁剪完后，发送给主函数的是顶点的数组，我们现在需要把他们装成一个个的三角形：</p>
<pre><code>1  
2  
3  
4  
5  
6  
7  
8  
9  
10  
11  
12  
13  
14  
15  
16  
17  
18  
19  
20  
21  
22  
23  
24  
25  
26  
27  
28  
29  
30  
31  
32  
33  
34  
35  
36  
37  
38  
39  
40  
41  
42  
43  
44  
45  
46  
47  
48  
49  
50  
51  
52  
53  
54  
55  
56  
57  
58  
59  
60  
61  
62  
63  
64  
65  
66  
67  
68  
69  
70  
71  
72  
73  
74  
75  
76  
77  
78  
79  
80  
81  
82  
</code></pre>
<p>| </p>
<pre><code>std::vector&lt;Vertex&gt; rasterizer::clip_Cohen_Sutherland(const Triangle&amp; t,  
	const std::array&lt;myEigen::Vector4f, 3&gt;&amp; clipSpacePos)  
{  
	auto v = t.vertex;  
  
	std::array&lt;Line, 3&gt; line  
	{  
		Line(v[0], v[1]),  
		Line(v[1], v[2]),  
		Line(v[2], v[0])  
	};  
  
	line[0] = clip_line(line[0], { clipSpacePos[0], clipSpacePos[1] });  
	line[1] = clip_line(line[1], { clipSpacePos[1], clipSpacePos[2] });  
	line[2] = clip_line(line[2], { clipSpacePos[2], clipSpacePos[0] });  
  
	int cnt = 0;  
	for (auto&amp; i : line) { if (i.empty()) cnt++; }  
  
	if (cnt == 3) return {};  
	if (cnt == 2)  
	{  
		return {};  
	}  
	else if (cnt == 1)  
	{  
		for (size_t i = 0; i &lt; 3; i++)  
		{  
			if (line[i].empty())  
			{  
				if (i == 0) {  
					line[i].v1 = line[2].v2;  
					line[i].v2 = line[1].v1;  
				}  
				else if (i == 1)  
				{  
					line[i].v1 = line[0].v2;  
					line[i].v2 = line[2].v1;  
				}  
				else if (i == 2)  
				{  
					line[i].v1 = line[1].v2;  
					line[i].v2 = line[0].v1;  
				}  
			}  
		}  
	}  
  
  
	std::vector&lt;Vertex&gt; newVert;  
	newVert.reserve(6);  
  
	if (fabs(line[2].v2.vertex.x - line[0].v1.vertex.x) &lt; 0.0001f &amp;&amp; fabs(line[2].v2.vertex.y - line[0].v1.vertex.y) &lt; 0.0001f)  
	{  
		newVert.emplace_back(line[0].v1);  
	}  
	else  
	{  
		newVert.emplace_back(line[2].v2);  
		newVert.emplace_back(line[0].v1);  
	}  
	if (fabs(line[0].v2.vertex.x - line[1].v1.vertex.x) &lt; 0.0001f &amp;&amp; fabs(line[0].v2.vertex.y - line[1].v1.vertex.y) &lt; 0.0001f)  
	{  
		newVert.emplace_back(line[1].v1);  
	}  
	else  
	{  
		newVert.emplace_back(line[0].v2);  
		newVert.emplace_back(line[1].v1);  
	}  
	if (fabs(line[1].v2.vertex.x - line[2].v1.vertex.x) &lt; 0.0001f &amp;&amp; fabs(line[1].v2.vertex.y - line[2].v1.vertex.y) &lt; 0.0001f)  
	{  
		newVert.emplace_back(line[2].v1);  
	}  
	else  
	{  
		newVert.emplace_back(line[1].v2);  
		newVert.emplace_back(line[2].v1);  
	}  
  
	return newVert;  
}  
  
</code></pre>
<p>—|—  </p>
<p>让我们看看结果：</p>
<p><img src="https://raw.githubusercontent.com/chiuhoukazusa/blog_img/main/202210160409634.gif" alt="裁剪"></p>
<p>大功告成！看起来是没有什么问题。不过旋转方向跟上一节的相反了，这不是我代码哪里写错了，是因为我现在才发现上一节做gif的时候图片顺序搞反了。。。导致上一节的旋转方向是反的，因为是“倒放”。</p>
<h3 id="背面剔除"><a href="#背面剔除" class="headerlink" title="背面剔除"></a>背面剔除</h3><p>很多时候，如果一个三角形背对着我们的时候，我们可以直接把他们剔除掉，因为大部分时候，我们处理的模型都是闭合模型，所以只需要渲染三角形朝向外面的面，对于三角形朝向内部的面我们直接剔除，可以大大减小算力。</p>
<p>这个做起来很简单，如果三角形顶点绕序是逆时针的话，我们用顶点依次相减得出两个三角形内部向量，再叉乘得到的法向量应该是指向摄像机的，我们再将三角形任意一个点跟摄像机位置连成一个向量，这两个向量点积得出的结果应该是负数，若不是负数则意味着是背面，需要剔除。</p>
<p>顶点绕序是顺时针的话反过来就行了。</p>
<p>相机空间的相机坐标是(0, 0, 0)，显然最适合做背面剔除，而且三角形光栅化可能会改变顶点顺序，所以相机空间做背面剔除无疑是非常合适的：</p>
<pre><code>1  
2  
3  
4  
5  
6  
7  
8  
9  
10  
11  
12  
13  
14  
15  
16  
17  
18  
19  
20  
21  
22  
23  
24  
</code></pre>
<p>| </p>
<pre><code>void rasterizer::TurnOnBackCulling()  
{  
    this-&gt;backCulling = true;  
}  
void rasterizer::TurnOffBackCulling()  
{  
    this-&gt;backCulling = false;  
}  
			...  
			//BackCulling  
			if (backCulling) {  
				auto v1 = vert[1] - vert[0];  
				auto v2 = vert[2] - vert[1];  
				auto v = myEigen::crossProduct(myEigen::Vector3f(v1.x, v1.y, v1.z), myEigen::Vector3f(v2.x, v2.y, v2.z));  
				auto gaze = myEigen::Vector3f(vert[0].x, vert[0].y, vert[0].z);  
				if (vertexOrder == TriangleVertexOrder::counterclockwise)  
				{  
					if (myEigen::dotProduct(v, gaze) &gt;= 0) return;  
				}  
				else  
				{  
					if (myEigen::dotProduct(v, gaze) &lt;= 0) return;  
				}  
			}  
  
</code></pre>
<p>—|—  </p>
<p>但是背面剔除是一个需要选择开启的功能，因为他对模型提出了闭合的要求，如果对于像草、树叶这些不闭合的模型来说，我们不能开启背面剔除，否则草只能看到一个面，我们绕到背面去看草就消失了，这肯定是不对的。而且为了演示方便，这一节里我也不会开启背面剔除。</p>
<h2 id="三角形光栅化"><a href="#三角形光栅化" class="headerlink" title="三角形光栅化"></a>三角形光栅化</h2><p>接下来我们要做的就是给三角形内部进行填色，我们将不只是满足于之前的线框渲染模式，我们将渲染出实心三角形。</p>
<p>三角形光栅化，说白了就是两个步骤，第一步是如何找到需要被光栅化的点，第二部是给需要被光栅化的点插值出需要的颜色、法线等属性。</p>
<h3 id="Edge-Walking"><a href="#Edge-Walking" class="headerlink" title="Edge Walking"></a>Edge Walking</h3><p>Edge Walking是一种常用于CPU软光栅的一种算法，有的人会把他称作扫描线算法，因为确实很像一根扫描线在上下来回扫描。</p>
<p>因为线段可以当做点的集合。那么我们不再计算孤立的一个点是否在三角形内，而是用水平的线来代替点。然后找到这条线与三角形的两个交点，自然两个交点中间的所有点都是我们这条线上的在三角形内部的点了。然后我们将线段往上移动一个像素再重复上述操作，直到三角形被“扫描”完全为止，这里的线段我们称之为“扫描线”。</p>
<p>我们先把三角形以y坐标第二大的顶点为界分为两个部分，上三角形和下三角形。</p>
<p><img src="https://raw.githubusercontent.com/chiuhoukazusa/blog_img/main/202210160409751.png" alt="scanline"></p>
<pre><code>1  
2  
3  
4  
5  
6  
7  
8  
9  
10  
</code></pre>
<p>| </p>
<pre><code>void rasterizer::rasterize_edge_walking(const Triangle&amp; m)  
{  
	Triangle t = m;  
	if (t.vertex[0].vertex.y &gt; t.vertex[1].vertex.y)  
		std::swap(t.vertex[0], t.vertex[1]);  
	if (t.vertex[0].vertex.y &gt; t.vertex[2].vertex.y)  
		std::swap(t.vertex[0], t.vertex[2]);  
	if (t.vertex[1].vertex.y &gt; t.vertex[2].vertex.y)  
		std::swap(t.vertex[1], t.vertex[2]);  
}  
  
</code></pre>
<p>—|—  </p>
<p>这样我们给三角形的顶点按从下到上排了个序，分界线就在vertex[2].vertex.y这根线上。</p>
<p>然后再对每个分割出来的三角形从下到上做扫描线，求出扫描线同三角形边相交的点。</p>
<p>这里求交点其实不需要靠什么直线方程来解决，可以直接通过线性插值来得到交点的坐标以及颜色等等。线性插值的系数t可通过当前扫描线的y坐标得到。</p>
<p>然后用这两个点给线段中的每一个像素再进行一次线性插值。这里给出下半部分三角形的代码：</p>
<pre><code>1  
2  
3  
4  
5  
6  
7  
8  
9  
10  
11  
12  
13  
14  
15  
16  
17  
18  
19  
20  
21  
22  
23  
</code></pre>
<p>| </p>
<pre><code>float longEdge = t.vertex[2].vertex.y - t.vertex[0].vertex.y;  
if (longEdge == 0) { return; }  
  
//scan the bottom triangle  
for (int y = std::ceil(t.vertex[0].vertex.y - 0.5f); y &lt; std::ceil(t.vertex[1].vertex.y - 0.5f); y++)  
{  
	float shortEdge = t.vertex[1].vertex.y - t.vertex[0].vertex.y;  
  
	float shortLerp = ((float)y + 0.5f - t.vertex[0].vertex.y) / shortEdge;  
	float longLerp = ((float)y + 0.5f - t.vertex[0].vertex.y) / longEdge;  
	  
	Vertex shortVertex = lerp(t.vertex[0], t.vertex[1], shortLerp);  
	Vertex longVertex = lerp(t.vertex[0], t.vertex[2], longLerp);  
  
	if (shortVertex.vertex.x &gt; longVertex.vertex.x)  
		std::swap(shortVertex, longVertex);  
	for (int i = std::ceil(shortVertex.vertex.x - 0.5f); i &lt; std::ceil(longVertex.vertex.x - 0.5f); i++)  
	{  
		float lerpNumber = ((float)i + 0.5f - shortVertex.vertex.x) / (longVertex.vertex.x - shortVertex.vertex.x);  
		Vertex pixel = lerp(shortVertex, longVertex, lerpNumber);  
		image.set(i, y, pixel.vertexColor);  
	}  
}  
  
</code></pre>
<p>—|—  </p>
<p>一定要注意精度问题！切记我们用屏幕中心的点的坐标来当做实际位置进行线性插值，但是image.set()里传入的两个int类型的坐标为像素左下角的坐标，一定要分清楚这个， 不然要么渲染相邻三角形的时候可能会出现缝隙，要么我们以后做抗锯齿的时候会很痛苦。</p>
<p>我们一般认为一个像素的中心在三角形内，那么这个像素就在三角形内。但如果三角形的边缘刚好穿过像素中心呢？从我们的代码可以看出来，一条扫描线穿过时，如果起点正好在像素中心，那么我们认为这个像素也在三角形内，但是终点如果在像素中心，那么我们认为这个像素不在三角形内。而如果是切割三角形的那条线穿过像素中心的话，我们认为这个像素属于下面那个三角形。看起来挺随意，但是可不能乱来，这都是有讲究的，我们在介绍另一种光栅化算法的时候将会着重提到具体的规则。</p>
<p>再加上渲染上半部分三角形的代码：</p>
<pre><code>1  
2  
3  
4  
5  
6  
7  
8  
9  
10  
11  
12  
13  
14  
15  
16  
17  
18  
19  
20  
</code></pre>
<p>| </p>
<pre><code>//scan the top triangle  
for (int y = std::ceil(t.vertex[1].vertex.y - 0.5f); y &lt; std::ceil(t.vertex[2].vertex.y - 0.5f); y++)  
{  
	float shortEdge = t.vertex[2].vertex.y - t.vertex[1].vertex.y;  
  
	float shortLerp = ((float)y + 0.5f - t.vertex[1].vertex.y) / shortEdge;  
	float longLerp = ((float)y + 0.5f - t.vertex[0].vertex.y) / longEdge;  
  
	Vertex shortVertex = lerp(t.vertex[1], t.vertex[2], shortLerp);  
	Vertex longVertex = lerp(t.vertex[0], t.vertex[2], longLerp);  
	  
	if (shortVertex.vertex.x &gt; longVertex.vertex.x)  
		std::swap(shortVertex, longVertex);  
	for (int i = std::ceil(shortVertex.vertex.x - 0.5f); i &lt; std::ceil(longVertex.vertex.x - 0.5f); i++)  
	{  
		float lerpNumber = ((float)i + 0.5f - shortVertex.vertex.x) / (longVertex.vertex.x - shortVertex.vertex.x);  
		Vertex pixel = lerp(shortVertex, longVertex, lerpNumber);  
		image.set(i, y, pixel.vertexColor);  
	}  
}  
  
</code></pre>
<p>—|—  </p>
<p>当然为了代码简洁我们肯定需要试着将这两个for循环合并到一起，不过这样又不是不能跑，我懒得写在一起，就先这样了，看看渲染结果：</p>
<p><img src="https://raw.githubusercontent.com/chiuhoukazusa/blog_img/main/202210160409852.gif" alt="edgewalking"></p>
<p>看着挺对的，可实际上对吗？</p>
<p><img src="https://raw.githubusercontent.com/chiuhoukazusa/blog_img/main/202210160409946.webp" alt="不对"></p>
<p>我们的插值其实并不对，还记得我们说过透视变换不是线性变换吗？那么屏幕空间的线性插值怎么能跟正常三维空间透视变换前的三角形的线性插值相提并论呢？</p>
<h3 id="2D空间下的透视矫正插值"><a href="#2D空间下的透视矫正插值" class="headerlink" title="2D空间下的透视矫正插值"></a>2D空间下的透视矫正插值</h3><p>这里引用一张虎书的插图，来直观地理解为什么屏幕空间的线性插值不正确：</p>
<p><img src="https://raw.githubusercontent.com/chiuhoukazusa/blog_img/main/202210160409049.png" alt="PerspectiveCorrectFigure"></p>
<p>这两张图都是4x4的正方形平面，被分割成了平均的16块。</p>
<p>左边那张图显然符合我们的生活常识，即使这些方格实际上都是一样大的，但是因为近大远小的关系看起来应该是左边这样扭曲过的，而右边的是直接用屏幕空间的线性插值顶点位置出来的结果。这显然不对，因为他把正方形经过透视投影变换而成的梯形当作原始图形来线性插值了，而我们想要的结果是透视投影前先做线性插值，再做透视投影变换。</p>
<p>这显然是做不到的，因为我们线性插值前需要先找到屏幕空间应该被光栅化的像素，怎么可能先线性插值再变换到屏幕空间呢？</p>
<p>所以我们需要从屏幕空间的像素坐标反推出它在透视投影变换前位于相机空间的哪个点，找出一个映射关系。</p>
<p>大家可以借鉴一下这篇文章的推导过程：</p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/403259571">图形学 - 关于透视矫正插值那些事</a></p>
<p>我这里直接给出他的结果</p>
<p>n&#x3D;mZ1(1−m)Z2+mZ1n&#x3D;\frac{mZ_1}{(1-m)Z_2+mZ_1} n&#x3D;(1−m)Z2​+mZ1​mZ1​​</p>
<p>m是屏幕空间下我们想要光栅化的像素的插值权重，n是这个像素对应到相机空间中的点的实际插值权重，Z1和Z2分别是我们要插值的两个坐标在相机空间下的深度值。</p>
<p>其中我们知道相机空间下的深度值在透视投影后变成了齐次裁剪空间中坐标的w值，所以我们可以只传递裁剪空间下的w值来计算。</p>
<pre><code>1  
2  
3  
4  
5  
6  
</code></pre>
<p>| </p>
<pre><code>inline Vertex perspectiveLerp(const Vertex&amp; v1, const Vertex&amp; v2, const float t,  
	const myEigen::Vector4f&amp; v1c, const myEigen::Vector4f&amp; v2c)  
{  
	float correctLerp = t * v2c.w / ((1 - t) * v1c.w + t * v2c.w);  
	return lerp(v1, v2, correctLerp);  
}  
  
</code></pre>
<p>—|—  </p>
<p>完整的透视校正下的EdgeWalking的代码如下：</p>
<pre><code>1  
2  
3  
4  
5  
6  
7  
8  
9  
10  
11  
12  
13  
14  
15  
16  
17  
18  
19  
20  
21  
22  
23  
24  
25  
26  
27  
28  
29  
30  
31  
32  
33  
34  
35  
36  
37  
38  
39  
40  
41  
42  
43  
44  
45  
46  
47  
48  
49  
50  
51  
52  
53  
54  
55  
56  
57  
58  
</code></pre>
<p>| </p>
<pre><code>void rasterizer::rasterize_edge_walking(const Triangle&amp; m, const std::array&lt;myEigen::Vector4f, 3&gt;&amp; clipSpacePos)  
{  
	Triangle t = m;  
	auto csp = clipSpacePos;  
	if (t.vertex[0].vertex.y &gt; t.vertex[1].vertex.y)  
		std::swap(t.vertex[0], t.vertex[1]); std::swap(csp[0], csp[1]);  
	if (t.vertex[0].vertex.y &gt; t.vertex[2].vertex.y)  
		std::swap(t.vertex[0], t.vertex[2]); std::swap(csp[0], csp[2]);  
	if (t.vertex[1].vertex.y &gt; t.vertex[2].vertex.y)  
		std::swap(t.vertex[1], t.vertex[2]); std::swap(csp[1], csp[2]);  
	float longEdge = t.vertex[2].vertex.y - t.vertex[0].vertex.y;  
	if (longEdge == 0) { return; }  
	//scan the bottom triangle  
	for (int y = std::ceil(t.vertex[0].vertex.y - 0.5f); y &lt; std::ceil(t.vertex[1].vertex.y - 0.5f); y++)  
	{  
		float shortEdge = t.vertex[1].vertex.y - t.vertex[0].vertex.y;  
  
		float shortLerp = ((float)y + 0.5f - t.vertex[0].vertex.y) / shortEdge;  
		float longLerp = ((float)y + 0.5f - t.vertex[0].vertex.y) / longEdge;  
  
		Vertex shortVertex = lerp(t.vertex[0], t.vertex[1], shortLerp);  
		Vertex longVertex = lerp(t.vertex[0], t.vertex[2], longLerp);  
		Vertex shortVertexC = perspectiveLerp(t.vertex[0], t.vertex[1], shortLerp, csp[0], csp[1]);  
		Vertex longVertexC = perspectiveLerp(t.vertex[0], t.vertex[2],longLerp, csp[0], csp[2]);  
  
		if (shortVertex.vertex.x &gt; longVertex.vertex.x)  
			std::swap(shortVertex, longVertex);  
		for (int i = std::ceil(shortVertex.vertex.x - 0.5f); i &lt; std::ceil(longVertex.vertex.x - 0.5f); i++)  
		{  
			float lerpNumber = ((float)i + 0.5f - shortVertex.vertex.x) / (longVertex.vertex.x - shortVertex.vertex.x);  
			Vertex pixel = perspectiveLerp(shortVertex, longVertex, lerpNumber, shortVertexC.vertex, longVertexC.vertex);  
			image.set(i, y, pixel.vertexColor);  
		}  
	}  
	//scan the top triangle  
	for (int y = std::ceil(t.vertex[1].vertex.y - 0.5f); y &lt; std::ceil(t.vertex[2].vertex.y - 0.5f); y++)  
	{  
		float shortEdge = t.vertex[2].vertex.y - t.vertex[1].vertex.y;  
  
		float shortLerp = ((float)y + 0.5f - t.vertex[1].vertex.y) / shortEdge;  
		float longLerp = ((float)y + 0.5f - t.vertex[0].vertex.y) / longEdge;  
  
		Vertex shortVertex = lerp(t.vertex[1], t.vertex[2], shortLerp);  
		Vertex longVertex = lerp(t.vertex[0], t.vertex[2], longLerp);  
		Vertex shortVertexC = perspectiveLerp(t.vertex[1], t.vertex[2], shortLerp, csp[1], csp[2]);  
		Vertex longVertexC = perspectiveLerp(t.vertex[0], t.vertex[2], longLerp, csp[0], csp[2]);  
  
		if (shortVertex.vertex.x &gt; longVertex.vertex.x)  
			std::swap(shortVertex, longVertex);  
		for (int i = std::ceil(shortVertex.vertex.x - 0.5f); i &lt; std::ceil(longVertex.vertex.x - 0.5f); i++)  
		{  
			float lerpNumber = ((float)i + 0.5f - shortVertex.vertex.x) / (longVertex.vertex.x - shortVertex.vertex.x);  
			Vertex pixel = perspectiveLerp(shortVertex, longVertex, lerpNumber, shortVertexC.vertex, longVertexC.vertex);  
			image.set(i, y, pixel.vertexColor);  
		}  
	}  
  
}  
  
</code></pre>
<p>—|—  </p>
<p>我们输出一下结果：</p>
<p><img src="https://raw.githubusercontent.com/chiuhoukazusa/blog_img/main/202210160409146.gif" alt="output0透视校正_1"></p>
<p>怎么感觉废了半天劲没啥变化？</p>
<p><img src="https://raw.githubusercontent.com/chiuhoukazusa/blog_img/main/202210160409267.jpg" alt="对吗"></p>
<p>让我们在<a target="_blank" rel="noopener" href="https://www.geogebra.org/calculator">GeoGebra计算器套件</a>里看一下这个式子的函数图像</p>
<p>n&#x3D;mZ1(1−m)Z2+mZ1n&#x3D;\frac{mZ_1}{(1-m)Z_2+mZ_1} n&#x3D;(1−m)Z2​+mZ1​mZ1​​</p>
<p><img src="https://raw.githubusercontent.com/chiuhoukazusa/blog_img/main/202210160409414.png" alt="函数图像"></p>
<p>Z1与Z2的差值越大，这个函数就越“凸”，也就是矫正与否的差别越大，而我们的三角形一是因为初始z值都是-2，在旋转中也拉不开太大距离。二是因为透视矫正在矫正顶点颜色插值的时候也不是很明显。所以我们的图像看起来与之前相差无几。可以使用photoshop叠图试试，或者加一行</p>
<pre><code>1  
</code></pre>
<p>| </p>
<pre><code>if (fabs(correctLN - 0.5) &lt; 0.05)pixel.vertexColor = TGAColor(255, 255, 255, 0);  
  
</code></pre>
<p>—|—  </p>
<p>把三角形的分割线中点与顶点的线段给画出来，再打开ps叠图，可以看到确实矫正后的中点判断比屏幕空间直接插值的结果有一个偏移量。</p>
<p><img src="https://raw.githubusercontent.com/chiuhoukazusa/blog_img/main/202210160409535.jpg" alt="对的"></p>
<p>我的debug模式下渲染71帧时间差不多5.8秒左右，看起来这个算法确实不错，我们现在已经可以像这个表情包里一样说”I know opengl”了。</p>
<p><img src="https://raw.githubusercontent.com/chiuhoukazusa/blog_img/main/202210160409655.jpg" alt="opengl"></p>
<h3 id="Edge-Equation"><a href="#Edge-Equation" class="headerlink" title="Edge Equation"></a>Edge Equation</h3><p>我们这里还要介绍一种更广泛运用在GPU硬件上的算法。也就是Edge Equation。GAMES101作业框架中用的也是这种方法。</p>
<p>Edge Walking虽然也很好用，但他其实在GPU时代已经被淘汰了，虽然我们的软光栅确实还有Edge Walking的一席之地，但不要忘了我们做软光栅不是为了做软光栅，而是为了更深刻地理解一些渲染基础知识。那么我们一定需要了解Edge Equation，或者说，一定需要了解三角形的重心坐标插值。</p>
<p>Edge Equation判断点是否在三角形内的方法比较简单粗暴，直接计算出三角形三条边的方程，即Ax+By+C&#x3D;0，然后把点的坐标直接代进去，因为直线会把屏幕分割成两个部分， 我们将代入出来的结果跟0比较，就可以知道点在哪个部分了。</p>
<p>然后我们把点的坐标代入三条直线方程，得出来的结果都大于0或者都小于0即代表点是否在三角形的内部。</p>
<p>GAMES101中闫令琪老师给了一个向量叉乘的算法，其实跟Edge Equation是等价的，算是换了一种方式理解直线方程。</p>
<p>当然我们需要做一个包围盒把三角形包起来，再遍历包围盒里的点，不然一个可能只占十几个像素的三角形我们都要遍历屏幕的每个像素的话就太扯淡了：</p>
<pre><code>1  
2  
3  
4  
5  
6  
7  
8  
9  
10  
11  
12  
13  
14  
15  
16  
17  
18  
19  
20  
21  
22  
23  
24  
25  
26  
27  
28  
29  
30  
31  
</code></pre>
<p>| </p>
<pre><code>void rasterizer::rasterize_edge_equation(const Triangle&amp; m, const std::array&lt;myEigen::Vector4f, 3&gt;&amp; clipSpacePos)  
{  
	int boundingTop = std::ceil(std::max({ m.vertex[0].vertex.y, m.vertex[1].vertex.y, m.vertex[2].vertex.y }));  
	int boundingBottom = std::floor(std::min({ m.vertex[0].vertex.y, m.vertex[1].vertex.y, m.vertex[2].vertex.y }));  
	int boundingRight = std::ceil(std::max({ m.vertex[0].vertex.x, m.vertex[1].vertex.x, m.vertex[2].vertex.x }));  
	int boundingLeft = std::floor(std::min({ m.vertex[0].vertex.x, m.vertex[1].vertex.x, m.vertex[2].vertex.x }));  
  
	for (int y = boundingBottom; y &lt; boundingTop; y++)  
	{  
		for (int x = boundingLeft; x &lt; boundingRight; x++)   
		{  
			if (insideTriangle(m, (float)x + 0.5, (float)y + 0.5))   
			{  
  
			}  
		}  
	}  
}  
  
static bool insideTriangle(const Triangle&amp; m, const float x, const float y)  
{  
	myEigen::Vector4f v1 = m.vertex[0].vertex;  
	myEigen::Vector4f v2 = m.vertex[1].vertex;  
	myEigen::Vector4f v3 = m.vertex[2].vertex;  
  
	float side1 = (v2.y - v1.y) * x + (v1.x - v2.x) * y + v2.x * v1.y - v1.x * v2.y;  
	float side2 = (v3.y - v2.y) * x + (v2.x - v3.x) * y + v3.x * v2.y - v2.x * v3.y;  
	float side3 = (v1.y - v3.y) * x + (v3.x - v1.x) * y + v1.x * v3.y - v3.x * v1.y;  
  
	return (side1 &gt;= 0 &amp;&amp; side2 &gt;= 0 &amp;&amp; side3 &gt;= 0) || (side1 &lt;= 0 &amp;&amp; side2 &lt;= 0 &amp;&amp; side3 &lt;= 0);  
}  
  
</code></pre>
<p>—|—  </p>
<p>这时我们就需要注意到三角形的边缘绘制问题了，如果一个三角形的边缘刚好经过了像素的中心，那这个像素算在三角形里吗？</p>
<p>闫令琪老师说不用特殊处理，对，但是也不对。</p>
<p>我们现在接触的目前还只是不透明物的渲染，如果涉及到半透明物体的渲染的时候。如果一对相邻三角形的临边穿过了像素中心点，我们如果对两个三角形都认为这个像素算在三角形里的话，会导致两个三角形在这个顶点的颜色叠加在一起，也就是overdraw了，图像渲染得不正确。</p>
<p>而如果我们认为这样的像素不在三角形里的话，很明显连不透明物体的渲染都会出问题，两条三角形的临边会看起来挖了洞一样。</p>
<p>所以不能摆烂不作处理，我们需要规定一个规则来规范边缘像素的所有权。</p>
<h3 id="Top-Left-Rules"><a href="#Top-Left-Rules" class="headerlink" title="Top-Left Rules"></a>Top-Left Rules</h3><p><a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/win32/direct3d11/d3d10-graphics-programming-guide-rasterizer-stage-rules?redirectedfrom=MSDN#triangle-rasterization-rules-without-multisampling">MSDN Top-Left Rules</a></p>
<p>这个规则是directx3D的处理规则，我们可以参考他们的规则来做。</p>
<p><img src="https://learn.microsoft.com/zh-cn/windows/win32/direct3d11/images/d3d10-rasterrulestriangle.png"></p>
<p>对于一条边跨过像素中心的情况，我们规定，如果这条边不是水平的，那么如果这条边是三角形“左边”的边，那么就属于三角形内。</p>
<p>如果这条边水平，那么如果这条边是三角形“上边”的边，那么就属于三角形内。</p>
<p>如何判断这条边是在topleft还是在bottomright呢？根据三角形的绕序来决定。</p>
<p>如果三角形绕序是逆时针的，那么可想而知，假设这条边的两个顶点分别为v1和v2，如果v1的y值大于v2的y值就说明这条边是三角形的“左”边，如果y值相同，那么v1的x值大于v2的x值就说明这条边是三角形的“上”边。</p>
<p>在实际代码中，我们的rules函数可以直接返回一个bias来影响判断：</p>
<pre><code>1  
2  
3  
4  
5  
6  
7  
8  
9  
10  
11  
12  
13  
14  
15  
16  
17  
18  
19  
20  
21  
22  
23  
24  
25  
26  
27  
28  
29  
30  
31  
32  
33  
</code></pre>
<p>| </p>
<pre><code>static int TopLeftRules(const float side, const myEigen::Vector4f&amp; v1, const myEigen::Vector4f&amp; v2,  
	const rst::TriangleVertexOrder&amp; Order)  
{  
	if (Order == TriangleVertexOrder::counterclockwise) {  
		if (fabs(side) &lt; 1e-6) {  
			return ((v1.y &gt; v2.y) || (v1.y == v2.y &amp;&amp; v1.x &gt; v2.x)) ? 0 : -1;  
		} else { return 0; }  
	}  
	else  
	{  
		if (fabs(side) &lt; 1e-6) {  
			return ((v1.y &lt; v2.y) || (v1.y == v2.y &amp;&amp; v1.x &lt; v2.x)) ? 0 : -1;  
		}  
		else { return 0; }  
	}  
}  
  
bool rasterizer::insideTriangle(const Triangle&amp; m, const float x, const float y)  
{  
	myEigen::Vector4f v1 = m.vertex[0].vertex;  
	myEigen::Vector4f v2 = m.vertex[1].vertex;  
	myEigen::Vector4f v3 = m.vertex[2].vertex;  
  
	float side1 = (v2.y - v1.y) * x + (v1.x - v2.x) * y + v2.x * v1.y - v1.x * v2.y;  
	float side2 = (v3.y - v2.y) * x + (v2.x - v3.x) * y + v3.x * v2.y - v2.x * v3.y;  
	float side3 = (v1.y - v3.y) * x + (v3.x - v1.x) * y + v1.x * v3.y - v3.x * v1.y;  
  
	side1 += TopLeftRules(side1, v1, v2, vertexOrder);  
	side2 += TopLeftRules(side2, v2, v3, vertexOrder);  
	side3 += TopLeftRules(side3, v3, v1, vertexOrder);  
  
	return (side1 &gt;= 0 &amp;&amp; side2 &gt;= 0 &amp;&amp; side3 &gt;= 0) || (side1 &lt;= 0 &amp;&amp; side2 &lt;= 0 &amp;&amp; side3 &lt;= 0);  
}  
  
</code></pre>
<p>—|—  </p>
<h3 id="三角形重心坐标系插值"><a href="#三角形重心坐标系插值" class="headerlink" title="三角形重心坐标系插值"></a>三角形重心坐标系插值</h3><p>判断完毕了那些像素点需要被光栅化后，我们下一步就是插值出每个像素点的属性值，不同于edge walking两次线性插值的是，edge equation中使用三角形重心坐标来插值。</p>
<p>数学上定义了三角形重心坐标系，我们来回顾一下相关知识。</p>
<p>这里借用虎书的插图</p>
<p><img src="https://raw.githubusercontent.com/chiuhoukazusa/blog_img/main/202210160409782.png" alt="重心坐标系"></p>
<p>想象这么一个坐标系，基向量为c-a和b-a，原点为a，那么点p可以这么表示：</p>
<p>p&#x3D;a+β(b−a)+γ(c−a)p&#x3D;a+β(b-a)+γ(c-a) p&#x3D;a+β(b−a)+γ(c−a)</p>
<p>我们把括号里的项拆出来</p>
<p>p&#x3D;(1−β−γ)a+βb+γcp&#x3D;(1-β-γ)a+βb+γc p&#x3D;(1−β−γ)a+βb+γc</p>
<p>令α&#x3D;1-β-γ，</p>
<p>那么我们定义一个三角形内的任何一个点p都可以用一个关于顶点A、B、C的线性组合来表示</p>
<p>p&#x3D;αa+βb+γcp&#x3D;αa+βb+γc p&#x3D;αa+βb+γc</p>
<p>其中α、β和γ都在(0, 1)范围内时才满足在三角形内的条件。</p>
<p>至于β和γ满足以下线性变换方程：</p>
<p>[xb−xaxc−xayb−yayc−ya][βγ]&#x3D;[xp−xayp−ya]\begin{bmatrix}x_b-x_a\quad x_c-x_a\\ y_b-y_a\quad y_c-y_a\end{bmatrix} \begin{bmatrix}β\\γ\end{bmatrix}&#x3D; \begin{bmatrix}x_p-x_a\\y_p-y_a\end{bmatrix} [xb​−xa​xc​−xa​yb​−ya​yc​−ya​​][βγ​]&#x3D;[xp​−xa​yp​−ya​​]</p>
<p>如果我们定义了二维矩阵就可以傻瓜式写出代码了，但是我们数学库里没定义这玩意儿。。。</p>
<p>所以直接求出结果代入吧：</p>
<p>γ&#x3D;(ya−yb)x+(xb−xa)y+xayb−xbya(ya−yb)xc+(xb−xa)yc+xayb−xbyaβ&#x3D;(ya−yc)x+(xc−xa)y+xayc−xcya(ya−yc)xb+(xc−xa)yb+xayc−xcyaα&#x3D;1−β−γγ&#x3D;\frac{(y_a-y_b)x+(x_b-x_a)y+x_ay_b-x_by_a}{(y_a-y_b)x_c+(x_b-x_a)y_c+x_ay_b-x_by_a}\\ β&#x3D;\frac{(y_a-y_c)x+(x_c-x_a)y+x_ay_c-x_cy_a}{(y_a-y_c)x_b+(x_c-x_a)y_b+x_ay_c-x_cy_a}\\ α&#x3D;1-β-γ γ&#x3D;(ya​−yb​)xc​+(xb​−xa​)yc​+xa​yb​−xb​ya​(ya​−yb​)x+(xb​−xa​)y+xa​yb​−xb​ya​​β&#x3D;(ya​−yc​)xb​+(xc​−xa​)yb​+xa​yc​−xc​ya​(ya​−yc​)x+(xc​−xa​)y+xa​yc​−xc​ya​​α&#x3D;1−β−γ</p>
<p>我们直接转换成代码：</p>
<pre><code>1  
2  
3  
4  
5  
6  
7  
8  
9  
10  
11  
12  
13  
14  
15  
16  
17  
18  
19  
20  
21  
22  
23  
24  
25  
26  
27  
28  
29  
30  
31  
32  
33  
34  
35  
36  
37  
38  
39  
</code></pre>
<p>| </p>
<pre><code>&quot;rasterizer.cpp&quot;  
	void rasterizer::rasterize_edge_equation(const Triangle&amp; m, const std::array&lt;myEigen::Vector4f, 3&gt;&amp; clipSpacePos)  
	{  
		int boundingTop = std::ceil(std::max({ m.vertex[0].vertex.y, m.vertex[1].vertex.y, m.vertex[2].vertex.y }));  
		int boundingBottom = std::floor(std::min({ m.vertex[0].vertex.y, m.vertex[1].vertex.y, m.vertex[2].vertex.y }));  
		int boundingRight = std::ceil(std::max({ m.vertex[0].vertex.x, m.vertex[1].vertex.x, m.vertex[2].vertex.x }));  
		int boundingLeft = std::floor(std::min({ m.vertex[0].vertex.x, m.vertex[1].vertex.x, m.vertex[2].vertex.x }));  
  
		for (int y = boundingBottom; y &lt; boundingTop; y++)  
		{  
			for (int x = boundingLeft; x &lt; boundingRight; x++)   
			{  
				if (insideTriangle(m, (float)x + 0.5, (float)y + 0.5))   
				{  
					Vertex pixel = barycentricLerp(m, myEigen::Vector2f(x + 0.5, y + 0.5));  
					image.set(x, y, pixel.vertexColor);  
				}  
			}  
		}  
	}  
  
&quot;geometry.cpp&quot;:  
	Vertex barycentricLerp(const Triangle&amp; t, const myEigen::Vector2f&amp; pixel)  
	{  
		Vertex v1 = t.vertex[0]; Vertex v2 = t.vertex[1]; Vertex v3 = t.vertex[2];  
		float xa = v1.vertex.x; float ya = v1.vertex.y;  
		float xb = v2.vertex.x; float yb = v2.vertex.y;  
		float xc = v3.vertex.x; float yc = v3.vertex.y;  
		float x = pixel.x; float y = pixel.y;  
  
		float gamma = ((ya - yb) * x + (xb - xa) * y + xa * yb - xb * ya) /  
			((ya - yb) * xc + (xb - xa) * yc + xa * yb - xb * ya);  
		float beta = ((ya - yc) * x + (xc - xa) * y + xa * yc - xc * ya) /  
			((ya - yc) * xb + (xc - xa) * yb + xa * yc - xc * ya);  
		float alpha = 1 - beta - gamma;  
  
		return v1 * alpha + v2 * beta + v3 * gamma;  
	}  
  
  
</code></pre>
<p>—|—  </p>
<p>这样还差最后一步，就是透视矫正。</p>
<h3 id="重心坐标下的透视矫正插值"><a href="#重心坐标下的透视矫正插值" class="headerlink" title="重心坐标下的透视矫正插值"></a>重心坐标下的透视矫正插值</h3><p>我们之前讨论的是2D空间下的透视矫正，用于处理EdgeWalking中两次线性插值的情况算是刚好合适，但是现在我们处理的是重心坐标插值，那么我们该怎么计算重心坐标在透视投影前后的alpha，beta与gamma之间的关系呢？</p>
<p>我们再来深入浅出一下透视投影发生了什么：</p>
<p>Mp[xyz1]&#x3D;[nxny(n+f)z−fnz]&#x3D;&gt;[nxznyzn+f−fnz1]M_p\begin{bmatrix}x\\y\\z\\1\end{bmatrix}&#x3D; \begin{bmatrix}nx\\ny\\(n+f)z-fn\\z\end{bmatrix}&#x3D;&gt; \begin{bmatrix}\frac{nx}{z}\\\frac{ny}{z}\\n+f-\frac{fn}{z}\\1\end{bmatrix} Mp​​xyz1​​&#x3D;​nxny(n+f)z−fnz​​&#x3D;&gt;​znx​zny​n+f−zfn​1​​</p>
<p>简化一下公式</p>
<p>Mp[xyz1]&#x3D;[wx′wy′wz′w]&#x3D;w[x′y′z′1]M_p\begin{bmatrix}x\\y\\z\\1\end{bmatrix}&#x3D; \begin{bmatrix}wx^{‘}\\wy^{‘}\\wz^{‘}\\w\end{bmatrix}&#x3D; w\begin{bmatrix}x^{‘}\\y^{‘}\\z^{‘}\\1\end{bmatrix} Mp​​xyz1​​&#x3D;​wx′wy′wz′w​​&#x3D;w​x′y′z′1​​</p>
<p>现在我们假设一个点P(x, y, z)和一个三角形，顶点为ABC，则满足重心坐标方程：</p>
<p>[P1]&#x3D;α[A1]+β[B1]+γ[C1]\begin{bmatrix}P\\1\end{bmatrix}&#x3D; α\begin{bmatrix}A\\1\end{bmatrix} + β\begin{bmatrix}B\\1\end{bmatrix} + γ\begin{bmatrix}C\\1\end{bmatrix} [P1​]&#x3D;α[A1​]+β[B1​]+γ[C1​]</p>
<p>方程两边左乘透视矩阵：</p>
<p>Mp[P1]&#x3D;αMp[A1]+βMp[B1]+γMp[C1]wp[P′1]&#x3D;αwa[A′1]+βwb[B′1]+γwc[C′1]M_p\begin{bmatrix}P\\1\end{bmatrix}&#x3D; αM_p\begin{bmatrix}A\\1\end{bmatrix} + βM_p\begin{bmatrix}B\\1\end{bmatrix} + γM_p\begin{bmatrix}C\\1\end{bmatrix}\\ w_p\begin{bmatrix}P^{‘}\\1\end{bmatrix}&#x3D; αw_a\begin{bmatrix}A^{‘}\\1\end{bmatrix} + βw_b\begin{bmatrix}B^{‘}\\1\end{bmatrix} + γw_c\begin{bmatrix}C^{‘}\\1\end{bmatrix} Mp​[P1​]&#x3D;αMp​[A1​]+βMp​[B1​]+γMp​[C1​]wp​[P′1​]&#x3D;αwa​[A′1​]+βwb​[B′1​]+γwc​[C′1​]</p>
<p>我们将这些向量从第三行“切”开，变成两个方程：</p>
<p>wpP′&#x3D;αwaA′+βwbB′+γwcC′wp&#x3D;αwa+βwb+γwcw_pP^{‘}&#x3D; αw_aA^{‘} + βw_bB^{‘} + γw_cC^{‘}\\ w_p&#x3D; αw_a + βw_b + γw_c\\ wp​P′&#x3D;αwa​A′+βwb​B′+γwc​C′wp​&#x3D;αwa​+βwb​+γwc​</p>
<p>直接把下面那个式子代入上边：</p>
<p>P′&#x3D;αwaA′+βwbB′+γwcC′αwa+βwb+γwc&#x3D;αwaαwa+βwb+γwcA′+βwaαwa+βwb+γwcB′+γwaαwa+βwb+γwcC′P^{‘}&#x3D; \frac{αw_aA^{‘} + βw_bB^{‘} + γw_cC^{‘}}{αw_a + βw_b + γw_c}\\ &#x3D;\frac{αw_a}{αw_a + βw_b + γw_c}A^{‘}+\frac{βw_a}{αw_a + βw_b + γw_c}B^{‘}+\frac{γw_a}{αw_a + βw_b + γw_c}C^{‘} P′&#x3D;αwa​+βwb​+γwc​αwa​A′+βwb​B′+γwc​C′​&#x3D;αwa​+βwb​+γwc​αwa​​A′+αwa​+βwb​+γwc​βwa​​B′+αwa​+βwb​+γwc​γwa​​C′</p>
<p>这样我们透视后的alpha、beta和gamma值与透视前的alpha、beta和gamma的关系就出来了</p>
<p>W&#x3D;1α′wa+β′wb+γ′wcα&#x3D;α′waWβ&#x3D;β′wbWγ&#x3D;γ′wcWW&#x3D;\frac{1}{\frac{α^{‘}}{w_a}+\frac{β^{‘}}{w_b}+\frac{γ^{‘}}{w_c}}\\ α&#x3D;\frac{\frac{α^{‘}}{w_a}}{W}\\ β&#x3D;\frac{\frac{β^{‘}}{w_b}}{W}\\ γ&#x3D;\frac{\frac{γ^{‘}}{w_c}}{W}\\ W&#x3D;wa​α′​+wb​β′​+wc​γ′​1​α&#x3D;Wwa​α′​​β&#x3D;Wwb​β′​​γ&#x3D;Wwc​γ′​​</p>
<p>直接开写：</p>
<pre><code>1  
2  
3  
4  
5  
6  
7  
8  
9  
10  
11  
12  
13  
14  
15  
16  
17  
18  
19  
20  
21  
22  
</code></pre>
<p>| </p>
<pre><code>Vertex barycentricPerspectiveLerp(const Triangle&amp; t, const myEigen::Vector2f&amp; pixel  
	, const std::array&lt;myEigen::Vector4f, 3&gt;&amp; v)  
{  
	Vertex v1 = t.vertex[0]; Vertex v2 = t.vertex[1]; Vertex v3 = t.vertex[2];  
	float xa = v1.vertex.x; float ya = v1.vertex.y;  
	float xb = v2.vertex.x; float yb = v2.vertex.y;  
	float xc = v3.vertex.x; float yc = v3.vertex.y;  
	float x = pixel.x; float y = pixel.y;  
  
	float g = ((ya - yb) * x + (xb - xa) * y + xa * yb - xb * ya) /  
		((ya - yb) * xc + (xb - xa) * yc + xa * yb - xb * ya);  
	float b = ((ya - yc) * x + (xc - xa) * y + xa * yc - xc * ya) /  
		((ya - yc) * xb + (xc - xa) * yb + xa * yc - xc * ya);  
	float a = 1 - b - g;  
  
	float W = 1.0f / (a / v[0].w + b / v[1].w + g / v[2].w);  
	float beta = (b / v[1].w) * W;  
	float gamma = (g / v[2].w)* W;  
	float alpha = 1.0f - beta - gamma;  
  
	return v1 * alpha + v2 * beta + v3 * gamma;  
}  
  
</code></pre>
<p>—|—  </p>
<p>输出结果：</p>
<p><img src="https://raw.githubusercontent.com/chiuhoukazusa/blog_img/main/202210160409892.gif" alt="EdgeEquation"></p>
<p>一模一样，但是同样是72帧花了8秒往上，显然对于单线程CPU来说这个算法更慢，而对于高度并行的GPU来说，这种逻辑简单，计算归结到每个像素内的算法显然比先给三角形一分为二，再用扫描线移动的EdgeWalking更加合适。</p>
<h2 id="深度测试"><a href="#深度测试" class="headerlink" title="深度测试"></a>深度测试</h2><p>目前为止我们只是对于一个三角形进行操作，一旦有多个三角形，我们就不得不思考一下遮挡关系的问题了。</p>
<p>一般来说深度测试在着色阶段的后面，可能会有点奇怪，如果先深度测试再着色不就能避免很多overdraw的问题了吗？</p>
<p>能避免，但也会带来其他问题。渲染效率上提升幅度确实很大，但是涉及到透明物体渲染，或者着色阶段的fragment shader编写中更改了深度信息，那么我们先进行深度测试就会导致渲染出错误的图像。</p>
<p>但是确实先做深度测试能带来渲染效率上的大提升，所以GPU硬件中已经集成了early-z的算法，可选择开启与否。</p>
<h3 id="画家算法与其局限性"><a href="#画家算法与其局限性" class="headerlink" title="画家算法与其局限性"></a>画家算法与其局限性</h3><p>画家算法就像他的名字一样好理解，怎么画出三角形的遮挡关系？答：从远及近给三角形排个序，先画远的再画近的。</p>
<p>看似粗暴，但是真的有用。但是对于一些复杂遮挡关系就没辙，比如下图：</p>
<p><img src="https://raw.githubusercontent.com/chiuhoukazusa/blog_img/main/202210160409001.png" alt="复杂遮挡关系"></p>
<p>你说这种怎么给三角形排个先后画的顺序呢？</p>
<p>而且传统的算法中对于三角形的前后排序涉及到空间分割的数据结构，一般是使用BSP树对三角形排序，对于三角形相互穿过的情况进行裁剪，但如果场景很大，或者物体动的很快的情形就不适用，即使是BSP树也会显得很慢，在如今我们无论是软光栅还是硬光栅，普遍使用的方法就是Z-Buffer。</p>
<h3 id="Z-Buffer"><a href="#Z-Buffer" class="headerlink" title="Z-Buffer"></a>Z-Buffer</h3><p>Z-Buffer说起来非常简单，创建一个Buffer来存储每个像素的深度值，当某个像素被覆盖时，将会与Z-Buffer里存储的当前像素已有深度值进行测试，如果离摄像机更近则覆盖上去，更远就什么也不做。</p>
<p>我们直接写一下代码，其实可以直接参考下tgaimage里data这个类似帧缓冲的实现：</p>
<pre><code>1  
2  
3  
4  
5  
6  
7  
8  
9  
10  
11  
12  
13  
14  
15  
16  
17  
18  
19  
20  
21  
22  
23  
24  
</code></pre>
<p>| </p>
<pre><code>rasterizer::rasterizer(const std::string&amp; f, const TGAImage&amp; img)  
	:filename(f), image(img), width(img.width()), height(img.height()),  
	zneardis(0.1f), zfardis(50), fovY(45), aspect(1)  
{  
	...  
	z_buffer.resize(img.width() * img.height());  
	std::fill(z_buffer.begin(), z_buffer.end(), -std::numeric_limits&lt;float&gt;::infinity());  
}  
  
int rasterizer::get_index(int x, int y)  
{  
	return y * width + x;  
}  
  
void rasterizer::rasterize_edge_equation(const Triangle&amp; m, const std::array&lt;myEigen::Vector4f, 3&gt;&amp; clipSpacePos)  
   {  
       ...  
           Vertex pixel = barycentricPerspectiveLerp(m, myEigen::Vector2f(x + 0.5, y + 0.5), clipSpacePos);  
           if (pixel.vertex.z &gt; z_buffer[get_index(x, y)])   
           {  
               image.set(x, y, pixel.vertexColor);  
               z_buffer[get_index(x, y)] = pixel.vertex.z;  
           }  
   }  
  
</code></pre>
<p>—|—  </p>
<p>EdgeEquation中的实现就是这样，EdgeWalking中的实现其实也一模一样，根本没几行代码的事。</p>
<p>看看结果（EdgeWalking）：</p>
<p><img src="https://raw.githubusercontent.com/chiuhoukazusa/blog_img/main/202210160409100.gif" alt="深度测试"></p>
<p>我传入的三角形是games101作业2中的三角形数据，传入顺序是先传前面的三角形，再传后面的三角形，但是结果依然给出了正确的遮挡关系，说明深度测试正确起效果了。</p>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>这一节很多内容比我想象的难一点，稍微做的晚了一些，而且依然有点缺憾，我后面也许会再出几篇文章补充一下。</p>
<p>首先是齐次坐标裁剪，我们并没有实现完整的齐次坐标裁剪，而是将其一部分工作转移到了屏幕空间进行，Cohen-Sutherland算法应该是完全可以拓展到3维或者4维的，这一点我写的时候没有考虑清楚，后续会再出一篇文章详细讲讲齐次坐标裁剪。</p>
<p>然后是深度测试的精度问题，我们忽略掉了很多事情，真正的Zbuffer储存在GPU上不同位数会有迥异的表现，而且我们处理的深度值没有做过任何变换，直接传入了原始的NDC坐标，会触及到一些浮点数精度之类的问题，也许这个也可能会再出篇文章讲讲深度测试的精度。</p>
<p>当然还是先出下一节为主，下一节不出意外的话应该是做纹理映射，我们会提前引入一个读取obj文件的头文件，届时应该可以看看我们渲染器的表现如何了。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://chiuhoukazusa.github.io">Chiuhou</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://chiuhoukazusa.github.io/2022/10/16/04-%E5%9C%A8MVP%E4%B9%8B%E5%90%8E%E8%A3%81%E5%89%AA-%E4%B8%89%E8%A7%92%E5%BD%A2%E5%85%89%E6%A0%85%E5%8C%96%E4%B8%8E%E6%B7%B1%E5%BA%A6%E6%B5%8B%E8%AF%95-github/">https://chiuhoukazusa.github.io/2022/10/16/04-%E5%9C%A8MVP%E4%B9%8B%E5%90%8E%E8%A3%81%E5%89%AA-%E4%B8%89%E8%A7%92%E5%BD%A2%E5%85%89%E6%A0%85%E5%8C%96%E4%B8%8E%E6%B7%B1%E5%BA%A6%E6%B5%8B%E8%AF%95-github/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://chiuhoukazusa.github.io" target="_blank">Chiuhou 技术博客</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/chiuhou-tech-blog/tags/C/">C++</a><a class="post-meta__tags" href="/chiuhou-tech-blog/tags/%E5%9B%BE%E5%BD%A2%E5%AD%A6/">图形学</a></div><div class="post-share"><div class="social-share" data-image="/chiuhou-tech-blog/images/Melina.png" data-sites="facebook,x,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/chiuhou-tech-blog/2023/01/18/05-%E8%BD%BD%E5%85%A53D%E6%A8%A1%E5%9E%8B%E6%A8%A1%E5%9E%8B%E5%8A%A0%E8%BD%BD%E4%B8%8E%E7%BA%B9%E7%90%86%E6%98%A0%E5%B0%84/" title="05.载入3D模型|模型加载、简单着色与纹理映射"><img class="cover" src="/chiuhou-tech-blog/images/Maria.jpg" onerror="onerror=null;src='/chiuhou-tech-blog/images/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">05.载入3D模型|模型加载、简单着色与纹理映射</div></div><div class="info-2"><div class="info-item-1">05.载入3D模型|模型加载、简单着色与纹理映射本项目代码已托管至github，将会随着博客实时更新进度每一节的工程我都会创建一个新的分支，分支名由这一节的数字决定。 https://github.com/chiuhoukazusa/LearningTinyrenderer/tree/05 前言在上一节的工作完成后，我们离渲染出一个正常的三维模型还剩下两步，纹理映射和着色，当然前提是得先把模型给加载了。 这一节先来尝试纹理映射和简单着色模型。 上一节我们说过要引入一个读取obj的头文件，但我觉得完全可以自己写一个简单的objloader，那就不引入了吧。 OBJ-MTL文件格式obj是最广泛使用的3维模型的格式，实际上obj只是一个纯文本文件，我们可以梳理出他的大致结构。而mtl也是一个纯文本文件，基本上和obj对应，会记录一些材质信息。 我们以games202的吉祥物为例来理解一下obj和mtl文件的结构： 1   2   3   4   5   6   7   8   9   10   11   12   13   14   15   16   17   18   19   ...</div></div></div></a><a class="pagination-related" href="/chiuhou-tech-blog/2022/09/23/03-HelloTrianglesMVP%E5%8F%98%E6%8D%A2/" title="03.HelloTriangles|MVP变换"><img class="cover" src="/chiuhou-tech-blog/images/lianlian.jpg" onerror="onerror=null;src='/chiuhou-tech-blog/images/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">03.HelloTriangles|MVP变换</div></div><div class="info-2"><div class="info-item-1">03.HelloTriangles|MVP变换本项目代码已托管至github，将会随着博客实时更新进度每一节的工程我都会创建一个新的分支，分支名由这一节的数字决定。 https://github.com/chiuhoukazusa/LearningTinyrenderer/tree/03 前言在上一节中，我们实现了一个基本可用的3d数学库，我们马上就会使用到他们。 这一节中我们将实现渲染的第一个流程，MVP变换。这一节的目标就是实现games101的作业1的效果，我们将会传入跟101作业中一样的参数，并检验产生的三角形是否一致。 MVP变换并不是有了上一节的矩阵运算法则基础就一下子就可以讲清的，要理解MVP变换，要先了解矩阵与图形变换的关系。 本节引用的图片来自《Fundamentals of Computer Graphics Fifth Edition》和《Physically Based Rendering From Theorty To Implementation Third Edition》，下文将分别简述为虎书和PBRT-v3。 变换矩阵(Transformatio...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/chiuhou-tech-blog/2022/09/15/02-%E7%AE%80%E5%8D%953D%E6%95%B0%E5%AD%A6%E5%BA%93%E5%B0%81%E8%A3%85%E5%90%91%E9%87%8F%E7%B1%BB%E5%92%8C%E7%9F%A9%E9%98%B5%E7%B1%BB/" title="02.简单3D数学库|封装向量类和矩阵类"><img class="cover" src="/chiuhou-tech-blog/images/Maria.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2022-09-15</div><div class="info-item-2">02.简单3D数学库|封装向量类和矩阵类</div></div><div class="info-2"><div class="info-item-1">02.简单3D数学库|封装向量类和矩阵类本项目代码已托管至github，将会随着博客实时更新进度每一节的工程我都会创建一个新的分支，分支名由这一节的数字决定。 https://github.com/chiuhoukazusa/LearningTinyrenderer/tree/02 前言在上一节的工程中，给定两个点，我们已经做到成功画出一条唯一确定的线段了。但是为了我们以后方便，我们显然需要封装向量类和矩阵类。当然我们可以直接使用Eigen库来完成这个问题，Eigen库非常的好用，但是我更想自己写一个试试。我们要做的其实完全不复杂，仅仅是封装几个类，并且没有什么性能要求，不会涉及到使用一些指令集来进行加速。所有的一切都将只用一些比较简单的c++代码进行实现。 本节代码参考了一部分pbrt-v3的配套代码中的geometry.h文件中的实现方式和DirectXMath库的设计方式，来封装一些简单的涉及3d数学的类。以下是pbrt-v3的源码： https://github.com/mmp/pbrt-v3 我们需要做的pbrt-v3中的数学库实现相当细致，不仅仅只是封装了向量和矩阵，...</div></div></div></a><a class="pagination-related" href="/chiuhou-tech-blog/2026/02/11/voronoi-diagram/" title="Voronoi 图生成器 - 计算几何的暴力之美"><img class="cover" src="https://raw.githubusercontent.com/chiuhoukazusa/blog_img/main/voronoi-2026-02-11/voronoi.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2026-02-11</div><div class="info-item-2">Voronoi 图生成器 - 计算几何的暴力之美</div></div><div class="info-2"><div class="info-item-1">Voronoi 图生成器 - 计算几何的暴力之美今天实现了经典的 Voronoi 图生成器，虽然使用暴力法（O(N×W×H)），但展示了计算几何的直观本质。 本项目代码已托管至 GitHub每日编程实践项目，记录每天的学习和实现。 https://github.com/chiuhoukazusa/daily-coding-practice/tree/main/2026/02/02-11-voronoi-generator  项目简介Voronoi 图是计算几何中非常重要的一种空间划分方法，将平面划分为若干个区域，每个区域内点到该区域对应的种子点的距离比到其他种子点更近。  开发时间: 约 13 分钟 代码量: 75 行 C++ 编译状态: ✅ 一次编译成功（0 错误，0 警告） 运行结果: ✅ 成功生成 800×600 像素的 Voronoi 图  技术要点Voronoi 图算法暴力法实现（Brute-force）： 1234567891011121314151617181920for (int y = 0; y &lt; height; y++) &#123;    for (...</div></div></div></a><a class="pagination-related" href="/chiuhou-tech-blog/2023/01/18/05-%E8%BD%BD%E5%85%A53D%E6%A8%A1%E5%9E%8B%E6%A8%A1%E5%9E%8B%E5%8A%A0%E8%BD%BD%E4%B8%8E%E7%BA%B9%E7%90%86%E6%98%A0%E5%B0%84/" title="05.载入3D模型|模型加载、简单着色与纹理映射"><img class="cover" src="/chiuhou-tech-blog/images/Maria.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-01-18</div><div class="info-item-2">05.载入3D模型|模型加载、简单着色与纹理映射</div></div><div class="info-2"><div class="info-item-1">05.载入3D模型|模型加载、简单着色与纹理映射本项目代码已托管至github，将会随着博客实时更新进度每一节的工程我都会创建一个新的分支，分支名由这一节的数字决定。 https://github.com/chiuhoukazusa/LearningTinyrenderer/tree/05 前言在上一节的工作完成后，我们离渲染出一个正常的三维模型还剩下两步，纹理映射和着色，当然前提是得先把模型给加载了。 这一节先来尝试纹理映射和简单着色模型。 上一节我们说过要引入一个读取obj的头文件，但我觉得完全可以自己写一个简单的objloader，那就不引入了吧。 OBJ-MTL文件格式obj是最广泛使用的3维模型的格式，实际上obj只是一个纯文本文件，我们可以梳理出他的大致结构。而mtl也是一个纯文本文件，基本上和obj对应，会记录一些材质信息。 我们以games202的吉祥物为例来理解一下obj和mtl文件的结构： 1   2   3   4   5   6   7   8   9   10   11   12   13   14   15   16   17   18   19   ...</div></div></div></a><a class="pagination-related" href="/chiuhou-tech-blog/2022/09/23/03-HelloTrianglesMVP%E5%8F%98%E6%8D%A2/" title="03.HelloTriangles|MVP变换"><img class="cover" src="/chiuhou-tech-blog/images/lianlian.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2022-09-23</div><div class="info-item-2">03.HelloTriangles|MVP变换</div></div><div class="info-2"><div class="info-item-1">03.HelloTriangles|MVP变换本项目代码已托管至github，将会随着博客实时更新进度每一节的工程我都会创建一个新的分支，分支名由这一节的数字决定。 https://github.com/chiuhoukazusa/LearningTinyrenderer/tree/03 前言在上一节中，我们实现了一个基本可用的3d数学库，我们马上就会使用到他们。 这一节中我们将实现渲染的第一个流程，MVP变换。这一节的目标就是实现games101的作业1的效果，我们将会传入跟101作业中一样的参数，并检验产生的三角形是否一致。 MVP变换并不是有了上一节的矩阵运算法则基础就一下子就可以讲清的，要理解MVP变换，要先了解矩阵与图形变换的关系。 本节引用的图片来自《Fundamentals of Computer Graphics Fifth Edition》和《Physically Based Rendering From Theorty To Implementation Third Edition》，下文将分别简述为虎书和PBRT-v3。 变换矩阵(Transformatio...</div></div></div></a><a class="pagination-related" href="/chiuhou-tech-blog/2026/02/17/daily-coding-shadow-ray-tracing-2026-02-17/" title="Shadow Ray Tracing - 光线追踪中的阴影算法实现"><img class="cover" src="https://raw.githubusercontent.com/chiuhoukazusa/blog_img/main/shadow-ray-tracing-2026-02-17/shadow_output.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2026-02-17</div><div class="info-item-2">Shadow Ray Tracing - 光线追踪中的阴影算法实现</div></div><div class="info-2"><div class="info-item-1">每日编程挑战：带阴影的光线追踪器今天实现了光线追踪中的阴影算法（Shadow Ray），并结合完整的Phong光照模型，创建了一个支持真实阴影效果的光线追踪渲染器。这是图形学渲染管线中的重要一步，为场景增加了深度感和真实感。 项目概述 实现语言：C++11 核心技术：Shadow Ray + Phong光照模型 + 多光源 输出格式：800×600 PNG图像 开发时长：10分钟（一次性编译成功）  什么是Shadow Ray？在光线追踪中，当主光线（Primary Ray）击中物体表面后，我们需要判断该点是否被其他物体遮挡。**Shadow Ray（阴影光线）**就是从交点向光源发射的一条测试光线。 算法原理12345671. 主光线击中物体表面，得到交点P2. 对场景中的每个光源L：   a. 从P向L发射一条Shadow Ray   b. 检查Shadow Ray在到达L之前是否击中其他物体   c. 如果击中 → P在阴影中（该光源不贡献光照）   d. 如果未击中 → P被照亮（计算该光源的光照贡献）3. 累加所有光源的贡献，得到最终颜色  代码实现1234567891...</div></div></div></a><a class="pagination-related" href="/chiuhou-tech-blog/2026/02/13/simple-ray-tracer-sphere-rendering/" title="每日编程实践：简单的光线追踪器渲染球体"><img class="cover" src="https://raw.githubusercontent.com/chiuhoukazusa/blog_img/main/ray-tracer-2026-02-13/output.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2026-02-13</div><div class="info-item-2">每日编程实践：简单的光线追踪器渲染球体</div></div><div class="info-2"><div class="info-item-1">每日编程实践：简单的光线追踪器渲染球体今天的目标是构建一个简单的光线追踪器来渲染一组球体场景，继续探索图形学中的光线追踪基础知识。   项目概述 项目名称: 简单的光线追踪器渲染球体 开发时间: 约15分钟 代码量: 143行 C++ 迭代次数: 1次（首次编译有小问题） 编译状态: ✅ 编译成功（0错误0警告） 运行结果: ✅ 成功生成600×400像素光线追踪图像 项目地址: GitHub - daily-coding-practice  技术要点光线追踪基本原理光线追踪的核心思想是从相机发射光线穿过每个像素，检测光线与场景中的物体是否相交，然后计算相交点的颜色。 三维向量运算实现光线追踪涉及大量的三维向量运算，为此需要实现基础的向量数学： 123456789struct Vec3 &#123;    float x, y, z;        Vec3 operator+(const Vec3&amp; v) const &#123; return Vec3(x + v.x, y + v.y, z + v.z); &#125;    Vec3 operator-(const...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/chiuhou-tech-blog/images/Melina.png" onerror="this.onerror=null;this.src='/chiuhou-tech-blog/images/404.jpg'" alt="avatar"/></div><div class="author-info-name">Chiuhou</div><div class="author-info-description">记录编程学习和项目实践，专注图形学、算法与工程实践</div><div class="site-data"><a href="/chiuhou-tech-blog/archives/"><div class="headline">文章</div><div class="length-num">14</div></a><a href="/chiuhou-tech-blog/tags/"><div class="headline">标签</div><div class="length-num">19</div></a><a href="/chiuhou-tech-blog/categories/"><div class="headline">分类</div><div class="length-num">4</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#04-%E5%9C%A8MVP%E4%B9%8B%E5%90%8E-%E8%A3%81%E5%89%AA%E3%80%81%E4%B8%89%E8%A7%92%E5%BD%A2%E5%85%89%E6%A0%85%E5%8C%96%E4%B8%8E%E6%B7%B1%E5%BA%A6%E6%B5%8B%E8%AF%95"><span class="toc-number">1.</span> <span class="toc-text">04.在MVP之后|裁剪、三角形光栅化与深度测试</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%AC%E9%A1%B9%E7%9B%AE%E4%BB%A3%E7%A0%81%E5%B7%B2%E6%89%98%E7%AE%A1%E8%87%B3github%EF%BC%8C%E5%B0%86%E4%BC%9A%E9%9A%8F%E7%9D%80%E5%8D%9A%E5%AE%A2%E5%AE%9E%E6%97%B6%E6%9B%B4%E6%96%B0%E8%BF%9B%E5%BA%A6"><span class="toc-number">1.1.</span> <span class="toc-text">本项目代码已托管至github，将会随着博客实时更新进度</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%89%8D%E8%A8%80"><span class="toc-number">1.2.</span> <span class="toc-text">前言</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%81%E8%A3%85Vertex%E7%B1%BB"><span class="toc-number">1.2.1.</span> <span class="toc-text">封装Vertex类</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9C%A8%E5%85%89%E6%A0%85%E5%8C%96%E4%B9%8B%E5%89%8D"><span class="toc-number">1.3.</span> <span class="toc-text">在光栅化之前</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A3%81%E5%89%AA-Clip-%E4%B8%8E%E5%89%94%E9%99%A4-Cull"><span class="toc-number">1.3.1.</span> <span class="toc-text">裁剪(Clip)与剔除(Cull)</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%EF%BC%9A%E6%88%91%E4%BB%AC%E7%8E%B0%E5%9C%A8%E6%A8%A1%E6%8B%9F%E7%9A%84%E9%98%B6%E6%AE%B5%E5%AF%B9%E5%BA%94%E7%9A%84%E6%98%AFGPU%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF%E4%B8%8A%E7%9A%84%E8%A3%81%E5%89%AA%EF%BC%8C%E8%80%8C%E9%9D%9E%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E9%98%B6%E6%AE%B5%E7%9A%84%E8%A7%86%E6%A4%8E%E4%BD%93%E5%89%94%E9%99%A4%E3%80%82%E4%B8%80%E8%88%AC%E6%9D%A5%E8%AF%B4%EF%BC%8C%E7%89%A9%E4%BD%93%E5%9C%A8%E4%BB%8Ecpu%E5%8F%91%E9%80%81%E5%88%B0gpu%E4%B9%8B%E5%89%8D%EF%BC%8C%E6%88%91%E4%BB%AC%E4%BC%9A%E5%85%88%E5%9C%A8cpu%E5%86%85%E5%AF%B9%E6%AF%8F%E4%B8%AA%E7%89%A9%E4%BD%93%E9%80%A0%E4%B8%80%E4%B8%AA%E5%8C%85%E5%9B%B4%E7%9B%92%EF%BC%8C%E5%86%8D%E7%94%A8%E5%8C%85%E5%9B%B4%E7%9B%92%E8%B7%9F%E8%A7%86%E6%A4%8E%E4%BD%93%E8%BF%9B%E8%A1%8C%E8%AE%A1%E7%AE%97%EF%BC%8C%E5%89%94%E9%99%A4%E9%82%A3%E4%BA%9B%E5%8C%85%E5%9B%B4%E7%9B%92%E9%83%BD%E4%B8%8D%E8%B7%9F%E8%A7%86%E6%A4%8E%E4%BD%93%E6%9C%89%E4%BB%BB%E4%BD%95%E4%BA%A4%E5%8F%89%E7%9A%84%E7%89%A9%E4%BD%93%E4%BB%A5%E5%87%8F%E5%B0%91draw-call%EF%BC%8C%E8%80%8Cgpu%E7%AB%AF%E7%9A%84%E5%89%94%E9%99%A4%E7%B2%92%E5%BA%A6%E6%9B%B4%E7%BB%86%EF%BC%8C%E9%9D%A2%E5%AF%B9%E7%9A%84%E5%AF%B9%E8%B1%A1%E6%98%AF%E9%82%A3%E4%BA%9B%E6%9E%84%E6%88%90%E7%89%A9%E4%BD%93%E7%9A%84%E5%9B%BE%E5%85%83%E3%80%82"><span class="toc-number">1.3.1.1.</span> <span class="toc-text">注意：我们现在模拟的阶段对应的是GPU渲染管线上的裁剪，而非应用程序阶段的视椎体剔除。一般来说，物体在从cpu发送到gpu之前，我们会先在cpu内对每个物体造一个包围盒，再用包围盒跟视椎体进行计算，剔除那些包围盒都不跟视椎体有任何交叉的物体以减少draw call，而gpu端的剔除粒度更细，面对的对象是那些构成物体的图元。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A3%81%E5%89%AA%E4%BD%8D%E4%BA%8E%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF%E7%9A%84%E4%BD%8D%E7%BD%AE"><span class="toc-number">1.3.1.2.</span> <span class="toc-text">裁剪位于渲染管线的位置</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E5%9C%A8CVV%E5%86%85%E5%81%9A%E8%A3%81%E5%89%AA%EF%BC%9F"><span class="toc-number">1.3.1.3.</span> <span class="toc-text">为什么不在CVV内做裁剪？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%BD%90%E6%AC%A1%E5%9D%90%E6%A0%87%E8%A3%81%E5%89%AA"><span class="toc-number">1.3.1.4.</span> <span class="toc-text">齐次坐标裁剪</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%88%91%E7%9A%84%E8%BD%AF%E4%BB%B6%E5%85%89%E6%A0%85%E5%99%A8%E4%B8%AD%E9%BD%90%E6%AC%A1%E5%9D%90%E6%A0%87%E8%A3%81%E5%89%AA%E7%9A%84%E6%96%B9%E5%BC%8F%E4%BB%85%E4%BE%9B%E5%8F%82%E8%80%83%EF%BC%8C%E5%B9%B6%E4%B8%8D%E4%BB%A3%E8%A1%A8%E5%AE%9E%E9%99%85%E7%9A%84GPU%E6%98%AF%E6%80%8E%E4%B9%88%E5%A4%84%E7%90%86%E8%A3%81%E5%89%AA%E7%B3%BB%E7%BB%9F%E7%9A%84%E3%80%82%E5%AE%9E%E9%99%85%E7%9A%84GPU%E5%BA%94%E8%AF%A5%E5%8F%AA%E4%BC%9A%E4%B8%A5%E6%A0%BC%E8%A3%81%E5%89%AA%E8%BF%91%E8%BF%9C%E5%B9%B3%E9%9D%A2%E7%9A%84%E5%9B%BE%E5%85%83%E6%9D%A5%E7%A1%AE%E4%BF%9D%E5%85%89%E6%A0%85%E5%8C%96%E7%BB%93%E6%9E%9C%E6%AD%A3%E7%A1%AE%EF%BC%8C%E8%80%8C%E5%AF%B9%E4%BA%8E%E5%B1%8F%E5%B9%95%E7%A9%BA%E9%97%B4%E5%8D%B3xy%E5%B9%B3%E9%9D%A2%E4%B8%8A%EF%BC%8CGPU%E4%BC%9A%E7%BB%99%E4%B8%80%E4%B8%AA%E6%AF%94%E6%88%91%E4%BB%AC%E5%B1%8F%E5%B9%95%E7%A9%BA%E9%97%B4%E5%A4%A7%E5%BE%97%E5%A4%9A%E7%9A%84%E7%9F%A9%E5%BD%A2%E6%9D%A5%E5%81%9A%E8%A3%81%E5%89%AA%E5%88%A4%E6%96%AD%EF%BC%8C%E8%BF%99%E6%A0%B7%E9%99%A4%E9%9D%9E%E6%98%AF%E8%B6%8A%E7%95%8C%E5%BE%97%E7%89%B9%E5%88%AB%E8%BF%87%E5%88%86%E7%9A%84%E5%9B%BE%E5%85%83%EF%BC%8C%E4%B8%8D%E7%84%B6%E4%B8%8D%E4%BC%9A%E8%A2%AB%E8%A3%81%E5%89%AA%E3%80%82%E5%AF%B9%E4%BA%8EGPU%E6%9D%A5%E8%AF%B4%EF%BC%8C%E5%81%9A%E4%B8%80%E4%BA%9B%E5%A4%8D%E6%9D%82%E7%9A%84%E8%A3%81%E5%89%AA%E7%AE%97%E6%B3%95%EF%BC%8C%E8%BF%98%E4%B8%8D%E5%A6%82%E8%AE%A9%E5%AE%83%E7%94%A8%E8%9B%AE%E5%8A%9B%E5%A4%9A%E7%AE%97%E5%87%A0%E4%B8%AA%E5%83%8F%E7%B4%A0%E6%9D%A5%E7%9A%84%E5%BF%AB%E3%80%82"><span class="toc-number">1.3.1.4.1.</span> <span class="toc-text">我的软件光栅器中齐次坐标裁剪的方式仅供参考，并不代表实际的GPU是怎么处理裁剪系统的。实际的GPU应该只会严格裁剪近远平面的图元来确保光栅化结果正确，而对于屏幕空间即xy平面上，GPU会给一个比我们屏幕空间大得多的矩形来做裁剪判断，这样除非是越界得特别过分的图元，不然不会被裁剪。对于GPU来说，做一些复杂的裁剪算法，还不如让它用蛮力多算几个像素来的快。</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Cohen-Sutherland%E7%AE%97%E6%B3%95"><span class="toc-number">1.3.1.5.</span> <span class="toc-text">Cohen-Sutherland算法</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%89%E8%A7%92%E5%BD%A2%E7%9A%84%E8%A3%81%E5%89%AA-%E7%BA%BF%E6%AE%B5%E7%9A%84%E8%A3%81%E5%89%AA-%E9%A1%B6%E7%82%B9%E7%9A%84%E8%A3%81%E5%89%AA"><span class="toc-number">1.3.1.5.1.</span> <span class="toc-text">三角形的裁剪-&gt;线段的裁剪-&gt;顶点的裁剪</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%83%8C%E9%9D%A2%E5%89%94%E9%99%A4"><span class="toc-number">1.3.2.</span> <span class="toc-text">背面剔除</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E8%A7%92%E5%BD%A2%E5%85%89%E6%A0%85%E5%8C%96"><span class="toc-number">1.4.</span> <span class="toc-text">三角形光栅化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Edge-Walking"><span class="toc-number">1.4.1.</span> <span class="toc-text">Edge Walking</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2D%E7%A9%BA%E9%97%B4%E4%B8%8B%E7%9A%84%E9%80%8F%E8%A7%86%E7%9F%AB%E6%AD%A3%E6%8F%92%E5%80%BC"><span class="toc-number">1.4.2.</span> <span class="toc-text">2D空间下的透视矫正插值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Edge-Equation"><span class="toc-number">1.4.3.</span> <span class="toc-text">Edge Equation</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Top-Left-Rules"><span class="toc-number">1.4.4.</span> <span class="toc-text">Top-Left Rules</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E8%A7%92%E5%BD%A2%E9%87%8D%E5%BF%83%E5%9D%90%E6%A0%87%E7%B3%BB%E6%8F%92%E5%80%BC"><span class="toc-number">1.4.5.</span> <span class="toc-text">三角形重心坐标系插值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8D%E5%BF%83%E5%9D%90%E6%A0%87%E4%B8%8B%E7%9A%84%E9%80%8F%E8%A7%86%E7%9F%AB%E6%AD%A3%E6%8F%92%E5%80%BC"><span class="toc-number">1.4.6.</span> <span class="toc-text">重心坐标下的透视矫正插值</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B7%B1%E5%BA%A6%E6%B5%8B%E8%AF%95"><span class="toc-number">1.5.</span> <span class="toc-text">深度测试</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%BB%E5%AE%B6%E7%AE%97%E6%B3%95%E4%B8%8E%E5%85%B6%E5%B1%80%E9%99%90%E6%80%A7"><span class="toc-number">1.5.1.</span> <span class="toc-text">画家算法与其局限性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Z-Buffer"><span class="toc-number">1.5.2.</span> <span class="toc-text">Z-Buffer</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%93%E8%AF%AD"><span class="toc-number">1.6.</span> <span class="toc-text">结语</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/chiuhou-tech-blog/2026/02/18/daily-coding-recursive-raytracing-2026-02-18/" title="每日编程实践：递归光线追踪 - 镜面反射"><img src="https://raw.githubusercontent.com/chiuhoukazusa/blog_img/main/reflection-raytracing-2026-02-18/reflection_output.png" onerror="this.onerror=null;this.src='/chiuhou-tech-blog/images/404.jpg'" alt="每日编程实践：递归光线追踪 - 镜面反射"/></a><div class="content"><a class="title" href="/chiuhou-tech-blog/2026/02/18/daily-coding-recursive-raytracing-2026-02-18/" title="每日编程实践：递归光线追踪 - 镜面反射">每日编程实践：递归光线追踪 - 镜面反射</a><time datetime="2026-02-18T03:35:00.000Z" title="发表于 2026-02-18 11:35:00">2026-02-18</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/chiuhou-tech-blog/2026/02/17/daily-coding-shadow-ray-tracing-2026-02-17/" title="Shadow Ray Tracing - 光线追踪中的阴影算法实现"><img src="https://raw.githubusercontent.com/chiuhoukazusa/blog_img/main/shadow-ray-tracing-2026-02-17/shadow_output.png" onerror="this.onerror=null;this.src='/chiuhou-tech-blog/images/404.jpg'" alt="Shadow Ray Tracing - 光线追踪中的阴影算法实现"/></a><div class="content"><a class="title" href="/chiuhou-tech-blog/2026/02/17/daily-coding-shadow-ray-tracing-2026-02-17/" title="Shadow Ray Tracing - 光线追踪中的阴影算法实现">Shadow Ray Tracing - 光线追踪中的阴影算法实现</a><time datetime="2026-02-17T02:00:00.000Z" title="发表于 2026-02-17 10:00:00">2026-02-17</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/chiuhou-tech-blog/2026/02/16/daily-coding-perlin-terrain-2026-02-16/" title="Perlin噪声地形生成器 - 程序化地形技术实践"><img src="https://raw.githubusercontent.com/chiuhoukazusa/blog_img/main/perlin-terrain-2026-02-16/terrain_512.png" onerror="this.onerror=null;this.src='/chiuhou-tech-blog/images/404.jpg'" alt="Perlin噪声地形生成器 - 程序化地形技术实践"/></a><div class="content"><a class="title" href="/chiuhou-tech-blog/2026/02/16/daily-coding-perlin-terrain-2026-02-16/" title="Perlin噪声地形生成器 - 程序化地形技术实践">Perlin噪声地形生成器 - 程序化地形技术实践</a><time datetime="2026-02-16T02:00:00.000Z" title="发表于 2026-02-16 10:00:00">2026-02-16</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/chiuhou-tech-blog/2026/02/15/daily-coding-ray-sphere-intersection-2026-02-15/" title="光线追踪：球体相交检测实现 - 图形学每日挑战"><img src="https://raw.githubusercontent.com/chiuhoukazusa/blog_img/main/2026-02-15-ray-sphere/ray_sphere_intersection.png" onerror="this.onerror=null;this.src='/chiuhou-tech-blog/images/404.jpg'" alt="光线追踪：球体相交检测实现 - 图形学每日挑战"/></a><div class="content"><a class="title" href="/chiuhou-tech-blog/2026/02/15/daily-coding-ray-sphere-intersection-2026-02-15/" title="光线追踪：球体相交检测实现 - 图形学每日挑战">光线追踪：球体相交检测实现 - 图形学每日挑战</a><time datetime="2026-02-15T02:00:00.000Z" title="发表于 2026-02-15 10:00:00">2026-02-15</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/chiuhou-tech-blog/2026/02/14/daily-coding-bresenham-2026-02-14/" title="Bresenham直线绘制算法实践 - 图形学每日挑战"><img src="https://raw.githubusercontent.com/chiuhoukazusa/blog_img/main/bresenham-2026-02-14/bresenham_output.png" onerror="this.onerror=null;this.src='/chiuhou-tech-blog/images/404.jpg'" alt="Bresenham直线绘制算法实践 - 图形学每日挑战"/></a><div class="content"><a class="title" href="/chiuhou-tech-blog/2026/02/14/daily-coding-bresenham-2026-02-14/" title="Bresenham直线绘制算法实践 - 图形学每日挑战">Bresenham直线绘制算法实践 - 图形学每日挑战</a><time datetime="2026-02-14T02:00:00.000Z" title="发表于 2026-02-14 10:00:00">2026-02-14</time></div></div></div></div></div></div></main><footer id="footer"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2025 - 2026 By Chiuhou</span><span class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 8.1.1</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.5.4</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/chiuhou-tech-blog/js/utils.js?v=5.5.4"></script><script src="/chiuhou-tech-blog/js/main.js?v=5.5.4"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>